:: StoryTitle
托托里之壶


:: StoryData
{
  "ifid": "BA16F8EA-42F7-407F-A5EC-1FF4DA8BFD8D",
  "format": "SugarCube",
  "format-version": "2.37.3",
  "start": "初始之地",
  "zoom": 0.6
}


:: "因为你没有母亲。" {"position":"1425,2800","size":"100,100"}
真想这样骂他，不知道卢恩会有什么反应。
可是现在还是先忍忍吧，毕竟有求于人的是我。

[[返回->怎样击败不死者之王？]]


:: "我会杀了你，然后把东西带走" {"position":"1075,900","size":"100,100"}
哥布林王：“如果这是宿命的话……来吧，我们接受你的挑战。”

[[王之间]]


:: PassageFooter {"position":"1200,100","size":"100,100"}
<<set _nowPassage to passage()>>\
<<if ['初始之地', '物品栏', '称号栏'].includes(passage())>>\
	<<set $footerOn to false>>\
<<else>>\
	<<set $footerOn to true>>\
<</if>>\
<<if $footerOn and $me>>\
<hr/>\
$me.name LV$me.level <<if $titles.items.length > 0>>【<<print $titles.items.last().name>>】<</if>>
<<set $expNeed to $nextLevelExp()>>\
经验值: $me.exp / $expNeed
HP :<meter @value="$me.hp" min="0" @max="$me.max_hp"></meter>
<<link "物品栏" "物品栏">><<audio "menu_click" play>><</link>>, <<link "称号栏" "称号栏">><<audio "menu_click" play>><</link>>
<<if $me.legacy>>遗物：<<link $me.legacy.name>><<audio "menu_click" play>><<set _temp to $showRelics()>><</link>> <<link "卸下" _nowPassage>><<audio "menu_click" play>><<set $me.legacy to null>><</link>><</if>>
<</if>>
<<script>>
	window.G = State.variables;
<</script>>


:: StoryCaption {"position":"825,250","size":"100,100"}
$me.name LV$me.level
<<set $expNeed to $nextLevelExp()>>\
<<set _nowPassage to passage()>>\
经验值: $me.exp / $expNeed
血量: $me.hp / $me.max_hp
武器: <<link $me.weapon.name>><<audio "menu_click" play>><<set $temp to $showWeapon()>><</link>>(攻击力: $me.weapon.power)
防具: <<link $me.armor.name>><<audio "menu_click" play>><<set $temp to $showArmor()>><</link>> (防御力:  $me.armor.resistance)
<<if $me.legacy>>遗物：<<link $me.legacy.name>><<audio "menu_click" play>><<set _temp to $showRelics()>><</link>> <<link "卸下" _nowPassage>><<set $me.legacy to null>><</link>><</if>>


:: StoryInit {"position":"1350,100","size":"100,100"}
<<cacheaudio "menu_click" "mp3|https://zhuobinggang.github.io/game/audio/sfx/menu_click.mp3">>\
dd
<<script>>
console.log('story init?')
<</script>>


:: “你去问不死者之王吧！“ {"position":"1300,2800","size":"100,100"}
”那么想知道，你去问不死者之王吧！“$me.name说。
听完，卢恩禁不住大笑起来。
好不容易等他笑完，卢恩开口了，”你真他妈是个小丑，看在你那么有趣的份上，我给你一点提示好了。“

[[提示->击败不死之王的提示]]


:: “我明白了，我会离开，把东西给我” {"position":"1075,1025","size":"100,100"}
<<silently>>
<<script>>
addItem(State.variables.inventory.items, State.variables['哥布林王权杖'], 1);
State.variables.showDialog('获得物品', '获得了' + State.variables['哥布林王权杖'].name + '!');
State.variables.goblinKingTalked = true;
<</script>>
<</silently>>
拿到了权杖，现在我可以风风光光地收拾哥布林王了。
（需要打开物品栏进行装备）

[[王之间]]


:: 一个男人 {"position":"725,1150","size":"100,100"}
从军队中站出来一个男人，他的头上缠着厚厚的绷带。


“哟，卡尔，你来迎接我了吗？”$me.name说，“用不着那么大排场的”。
沉默。

“你为什么露出这样的表情？”我说，“到底发生了什么事，是遇到了一种特殊的，永远无法弥补的不幸吗？我们真的无法从中恢复过来了吗？一切都完蛋了吗？”

“你为什么要做出<span class='red'>那样的事情</span>？”卡尔问。

“[[那样的事情->这样的事情]]？”


:: 一些东西 {"position":"1275,1525","size":"100,100"}
身着白色长袍的女性站在那儿，嘴唇在动。
她的表情哀伤，唤起你的同情，你想听听她在说些什么，于是你便听见了。

他是个混蛋，可是我爱他，女人说，苍白的脸颊甚至染上一丝绯红。
但是这副表情很快便消散了。
所以我会亲手杀死他，女人说。
沉默。
你的视野上下一往复，似乎是在点头。
女人笑了笑，转身离去。

这时你想起来她的名字——梅利。

[[……->关于索尔坦]]


:: 一本翻开的书 {"position":"525,250","size":"100,100"}
仔细一看，这不是一本书，而是自己写下的笔记。最上面的一页写着：

我没有过去的记忆。
老头也不向我透露任何东西。
也许这是一个阴谋，但是现在的我不得而知。

唯独一句话，深深刻印在我的脑海里——
“<span class="orange">你要成为勇者</span>。”
究竟是谁说的，我想不起来了，
可是也正因如此，才令我无法抗拒。
那就成为勇者吧，试着拯救世界不也挺好的吗？

明天就是我的十六岁生日了，
我一定要离开这个家，踏上旅程。
旅程会给我答案。

[[返回->起居室]]


:: 下一页 {"position":"850,525","size":"100,100"}
🖕

我还想你来告诉我我的身世呢，你这个BYD不孝玩意。

[[老头的房间]]

<<script>>
State.variables.oldManLetterRead = true
<</script>>


:: 不死之王初见 {"position":"850,2275","size":"100,100"}
在墓碑的包围下，从泥土中探出半身的巨大骷髅。
头顶皇冠，黑黝黝的眼窝中飘着两抹凶光。

<<link "🔴挑战不死者之王" "战斗画面">>\
	<<set $undeadKing.hp to $undeadKing.max_hp>>\
	<<set $lastPassage to "破土而出">>\
    <<set $enemyNames to ['undeadKing']>>\
<</link>>
[[逃跑->逃离不死者之王]]


:: 不死王座 {"position":"1600,2300","size":"100,100"}
=不死王座=
<<silently>>\
<<script>>
	let G = State.variables;
	G.purifierCount = getItem(G.inventory.items, '秽土净化者')?.count || 0;
<</script>>
<<if not $undeadKing.legacy and $karlTheReviver.hp > 0>>
<<goto "卡尔无头骑士">>
<</if>>
<</silently>>\

大墓地的中央，愈靠近，四周愈显得黑暗，
似乎光也在逃离这个地方。

你已经不是第一次来到这里了。

<<if $undeadKing.hp < 1>>
不死者之王已经死了！但是接下来的故事我还没做好！
<<else>>
在墓碑的包围下，从泥土中探出半身的巨大骷髅。
头顶皇冠，黑黝黝的眼窝中飘着两抹凶光。
<<link "🔴挑战不死者之王" "战斗画面">>\
	<<set $undeadKing.hp to $undeadKing.max_hp>>\
	<<set $lastPassage to passage()>>\
    <<set $enemyNames to ['undeadKing']>>\
<</link>>\
<</if>>\

<<if $purifierCount > 0>>🟠[[使用秽土净化者]]<</if>>

[[逃跑->大墓地外围]]


:: 不祥的红色灵魂 {"position":"975,1525","size":"100,100"}
“看看谁来了，”红色的灵魂开口了，“亲爱的客人，你是需要售后服务吗？还有旁边这位戴兜帽的客人……哦，是吗，这就是你的选择吗。”

“你知道接下来要面对的是谁吧。”兜帽说。
我点点头。
仅仅感受到它的存在就令我的眼窝生疼——剜眼者，这就是它的名字。

“把我的眼睛还来。”
“刁难人的请求本店不予受理。”剜眼者说到，“你的眼球已经被我吃掉了。”

<<link "🔴进入战斗" "战斗画面">>\
	<<set $theEyeScooper.hp to $theEyeScooper.max_hp>>\
	<<set $lastPassage to '行刑室'>>\
    <<set $enemyNames to ['theEyeScooper']>>\
<</link>>
[[再等等->行刑室]]


:: 与卢恩交谈 {"position":"1175,2425","size":"100,100"}
"我会帮你击败不死者之王，但是你需要准备好一些必要的东西。"卢恩说。

🟠[[必要的东西]]
[[遗物升级]]
[[击败不死之王的提示]]
[[返回->大墓地外围]]

<<if $gotDirtPurifier>><<goto "卢恩的催促">><</if>>


:: 之后的事情 {"position":"1050,2925","size":"100,100"}
”到了不死王座之后再启动，“卢恩说。

”击败不死之王之后……会发生什么事？“
”你知道了又能怎么样呢？我们只能尽力做好自己能做的事情不是吗。“卢恩说，”即便世界毁灭，你也要打破这个状况不是吗？总不能永远留在这个不毛之地吧？“
$me.name陷入了沉默。

”走吧，去做你应该做的事情。“

[[离开->大墓地外围]]


:: 交出5个史莱姆粘液 {"position":"425,375","size":"100,100"}
<<script>>
let itemName =  '史莱姆粘液'
reduceItemCount(State.variables.inventory.items, itemName, 5)
State.variables.temp = getItem(State.variables.inventory.items, itemName)
addItem(State.variables.inventory.items, State.variables.clownMask, 1)
<</script>>
把5个史莱姆粘液给了老头，现在只剩下$temp.count个了。
不过也没什么好可惜的。

作为回报，老头给了你一个小丑面具。

[[返回->向老头搭话]]


:: 休息 {"position":"525,125","size":"100,100"}
经过剧烈的休息，体力恢复了！
<<set $me.hp to $me.max_hp>>\

[[起居室]]


:: 低矮墓地 {"position":"1475,2300","size":"100,100"}
=低矮墓地=

视野开阔的低矮墓地群。
灌木丛中晃动着一些黄色的影子。
仔细观察能够发现，那是一些类似史莱姆的生物，不过颜色是半透明的黄色。
<<link "发起攻击" "战斗画面">>
	<<set $lastPassage to passage()>>\
    <<set $silverIodideOozingOne.hp to $silverIodideOozingOne.max_hp>>
    <<set $enemyNames to ['silverIodideOozingOne']>>\
<</link>>\

<<if random(100) < 30>>
🟠空中飘荡着一团淡蓝色的，火焰一样的存在。
<<link "发起攻击" "战斗画面">>
	<<set $lastPassage to passage()>>\
    <<set $soulClumps.hp to $soulClumps.max_hp>>
    <<set $enemyNames to ['soulClumps']>>\
<</link>>\
<</if>>

[[大墓地外围]]


:: 低矮林地 {"position":"575,525","size":"100,100"}
<<set $slime.hp to $slime.max_hp>>\
<<set $slimeZombie.hp to $slime.max_hp>>\
=低矮林地=

屋子旁边的小树林。
这里生活着很多弱小的魔物。
目力所及的地方就有很多史莱姆。
<<link "攻击史莱姆" "战斗画面">>\
	<<set $lastPassage to '低矮林地'>>\
	<<if random(100) < 30>>
		<<set $enemyNames to ['slimeZombie']>>\
	<<else>>
		<<set $enemyNames to ['slime']>>\
	<</if>>
<</link>>
<<link "同时攻击3只史莱姆" "战斗画面">>\
	<<set $lastPassage to '低矮林地'>>\
    <<silently>>\
    <<script>>
        const G = State.variables;
        // spawn slimes
        G.enemyNames = []
        for (let i = 0; i < 3; i++) {
			const enemyName = 'slime_' + i;
			let slimeCloned = null;
			if (Math.random() < 0.3){
				G.slimeZombie.legacy = null;
				slimeCloned = structuredClone(G.slimeZombie);
				slimeCloned.legacy = G.healer5; // 遗物有回调，没法克隆
				G.slimeZombie.legacy = G.healer5;
			} else {
				slimeCloned = structuredClone(G.slime);
			}
            slimeCloned.name = `${slimeCloned.name}`;
            G[enemyName] = slimeCloned;
            G.enemyNames.push(enemyName);
        }
    <</script>>
    <</silently>>\
<</link>>

<<if $theClownInWoods.hp > 0 and random(100) < 100>>\
🟠树枝上吊着一个小丑。
[[向他搭话->向小丑搭话]]
<<link "攻击小丑" "战斗画面">>\
	<<set $lastPassage to '低矮林地'>>\
    <<set $enemyNames to ['theClownInWoods']>>\
<</link>>
<</if>>\

返回[[小屋前十字路口]]


:: 你能不能先从那里出来 {"position":"475,1025","size":"100,100"}
“细微的调节尚未实现，”怪人说，“我的朋友，请告诉我这是哪里。”

“方位上是王国东南。”$me.name回答道。
王国全名其实叫底里斯王国，但是说王国大部分人也都明白。

“居然给我干这种地方来了。”

“你是谁，是人类吗？”
“人类已经不足以定义我，我是人类以上的存在，天才学者卢恩！”
只明白了他是个怪人。

“没时间了，有机会的话到布里斯坦王国来，就说是找天才学者卢恩。到时候我再向你解释。”

眼看着那人的腿上出现了一些亮绿色的噪点。
当然了，$me.name不能够理解这幅光景的意味，只觉得毛骨悚然。

“又或者……“似乎想起来什么一样，卢恩开口道，”<span class='important'>命运会指引我们相遇的</span>。”
话音戛然而止，两条腿凭空消失，只留下了和往常一样的岩石。

[[片刻之后]]


:: 使用秽土净化者 {"position":"1600,2425","size":"100,100"}
$me.name撑开秽土净化者——
什么都没有改变。

[[静待片刻]]


:: 偷偷溜走 {"position":"725,650","size":"100,100"}
“站住！”
身后传来老头严厉的声音。

老头全天二十四小时都在警戒$me.name的出逃，
必须想办法解决这个状况。

[[返回->小屋前十字路口]]


:: 关于索尔坦 {"position":"1125,1650","size":"100,100"}
身材魁梧的男人站在那儿。
你就是新来的家伙？连像样的装备都没有，怕是连一头哥布林都杀不死吧？
男人哧笑道，毫不遮掩对你的轻蔑。

我不知道你是托了什么关系才进来的，也没兴趣知道，你记住乖乖听我指挥就行，让你送命的时候就乖乖送命，这就是你能为这个世界做出的最大贡献。

这个男人叫索尔坦，王国指定勇者。
他有一个不为人知的身份。
他秘密通敌，把重要军事情报交给敌国，意图引发战乱。

[[……->混乱的终幕]]


:: 击败不死之王的提示 {"position":"1175,2800","size":"100,100"}
”提示，”卢恩说，“我已经跟你说过了。”
说过了？你不禁回忆起和他的交谈。

……
复活，准确来说是躯体的无限再生。
躯体——或者说肉体，跟灵魂异质的存在。
<span class="orange">他刚才说了什么来着？跟肉体有关的</span>……

[[对了，是那个……]]


:: 击败卡尔剧情 {"position":"975,1900","size":"100,100"}
卡尔手中的巨剑，喋血者，有一个不为人知的特性。
它对杀死前持有者的人有着异样的执着。
无论任何情况，只要被划到，一击致命。

你已经死了，出现在这里只是一种假象。

[[回到真实世界->和卡尔战斗之后]]

<<script>>
let G = State.variables;
G.karl.hp = G.karl.max_hp;
<</script>>


:: 击败卡尔复生者 {"position":"1975,2550","size":"100,100"}
结束了。

卡尔的头被$me.name砍下。

即便他有再强的恢复力也没有用。
没有思考能力的肉体，只是一具行尸走肉罢了。

[[对付不死者之王->卡尔站了起来]]


:: 击败卡尔无头骑士 {"position":"2100,2300","size":"100,100"}
卡尔的身躯已经千疮百孔。
只剩下一个头，再怎样都已经无力回天。

在临死之前，卡尔开口了。

[[真相]]


:: 初始之地 {"position":"700,100","size":"100,100"}
<<set $default_weapon to {name: '空手', power: 1, desc: '拳头就是最好的武器。'}>>\
<<set $default_armor to {name: '运动服', resistance: 1, desc: '居家用。'}>>\
<<set $me to {name: '你爹', hp: 100, max_hp: 100, weapon: $default_weapon, armor: $default_armor, intrinsicPower: 0, intrinsicResistance: 0, level: 1, exp: 0}>>\
我的名字叫作：
<<textbox "$me.name" "父亲">>

[[进入游戏->起居室]]


<<set $inventory to {desc: '物品栏', items: []}>>
<<set $titles to {desc: '称号', items: []}>>

<<set $beginnerWeaponGot to false>>
<<set $beginnerWeapon to {name: '木剑', power: 2, desc: '平凡的木剑。'}>>
<<set $beginnerArmor to {name: '鹿皮夹克', resistance: 2, desc: '随处可见的鹿皮夹克。'}>>
<<set $bloodedIronSword to {name: '染血的铁剑', power: 5, desc: '由于血污变钝了一些。'}>>
<<set $bloodedDeerskinArmor to {name: '染血的鹿皮夹克', resistance: 4, desc: '散发着令人恶心的腥臭。'}>>

<<set $footerOn to true>>

/* NPC & Monsters */
<<script>>
window.G = State.variables;
console.log('HELLO?')
State.variables.slimeDrop =  {name: '史莱姆粘液', desc: '史莱姆掉落的粘稠液体，应该不会有人需要吧？'};
State.variables.slimeSoul =  {name: '史莱姆的灵魂', desc: '史莱姆的天真灵魂。'};
State.variables.clownMask = {
	name: '小丑面具',  desc: '看起来有些诡异的面具，能够吓哭小孩。'
}
State.variables.oldMan = {name: '老头', max_hp: 100, hp: 100, power: 4, resistance: 2, exp: 100, drops: [{item: G.clownMask, chance: 1, count: 10}]};
State.variables.slime = {
	name: '史莱姆', 
    exp: 3,
    max_hp: 10,
    hp: 10, 
    power: 1, 
    resistance: 1, 
    drops: [{item: State.variables.slimeDrop, chance: 0.8, count: 3}, {item: State.variables.slimeSoul, chance: 0.6}, ]
}
State.variables.oldManSlayer = {
	name: '俄狄浦斯',  desc: '只是杀死了个老头而已，有什么好大惊小怪的。'
}
State.variables.slimeSlayer = {
	name: '史莱姆杀手',  desc: '最好不要让动物保护协会知道。'
}
State.variables.goblinSlayer = {
	name: '护甲击破者',  desc: '第一次击败山岭哥布林。'
}
State.variables.healMySelf = function healMySelf(percentage){
	healing(State.variables.me, percentage);
}
State.variables.useSmallHealingPotion = function useSmallHealingPotion(){
	healing(State.variables.me, 0.2);
    reduceItemCount(State.variables.inventory.items, '小回复瓶');
}
State.variables.smallHealingPotion = {
	name: '小回复瓶',  desc: '回复20%HP。', useCallback: State.variables.useSmallHealingPotion
}
// 增加经验
State.variables.levelUpMe = function levelUpMe(){
	window.levelUp(State.variables.me)
}
State.variables.addExp = function  addExp(exp){
	console.log('获取了' + exp + '点经验')
	let {newExp, newLevel, levelsGained} = expGot(State.variables.me.exp, exp, State.variables.me.level, State.variables.levelUpMe);
    console.log('newExp ' + exp + '点经验')
    State.variables.me.exp = newExp;
}
State.variables.nextLevelExp = function(){
	return expCurve(State.variables.me.level);
}
State.variables.showDialog = function(title, text){
    Dialog.create(title);
    Dialog.wiki(text);
    Dialog.open();
}
State.variables.showDialogWithTextList = function(title, textList){
    Dialog.create(title);
	let text = textList.join('\n');; // 请帮我补充这一行，使用换行符来换行即可
    Dialog.wiki(text);
    Dialog.open();
}
State.variables.showWeapon = function(){
	let title = State.variables.me.weapon.name
    let desc = State.variables.me.weapon.desc
	State.variables.showDialog(title, desc)
}
State.variables.showArmor = function(){
	let title = State.variables.me.armor.name
    let desc = State.variables.me.armor.desc
	State.variables.showDialog(title, desc)
}
State.variables.showRelics = function(){
	let title = State.variables.me.legacy.name
    let desc = State.variables.me.legacy.desc
	State.variables.showDialog(title, desc)
}
State.variables.globalUseCallback = function(idx){
	console.log('globalUseCallback ' + idx);
    console.log('I am going to call ' + State.variables.inventory.items[idx].name + ' callback');
    State.variables.inventory.items[idx].useCallback()
}
State.variables.showDialogFightHistory = function(){
	State.variables.showDialogWithTextList('战斗记录', State.variables.fightHistory)
}
// 2024.10.25将enemyVarName废弃，改成enemies以支持组战斗
// 2024.10.25由于引用在每个新段落都会被破坏，只能通过保存名字的方式来保持联系
State.variables.enemyNames = [];
console.log('I am done')
const useRodSlime = () => {
	const rodName = '万圣节权杖';
	window.G.me.legacy = G[rodName];
	window.G.showDialog('装备遗物', '成功装备了' + rodName + '!');
}
G.rodSlimeLevel = 1;
G.rodSlimeScalar = (level) => {
	return level * 1.0;
}
const rodSlimeGroupModifier = (group1, group2, fightHistory) => {
	const rodName = `万圣节权杖lv.${G.rodSlimeLevel}`;
	const prototFightObj = State.variables.slime;
	const familiarName = '【使魔】史莱姆';
	const spawned = fightObjectCopy(prototFightObj, G.rodSlimeScalar(G.rodSlimeLevel));
	console.log(spawned);
	spawned.name = familiarName;
	group1.push(spawned);
	console.log(rodName + '为' + group1[0].name + '的队伍召唤了' + familiarName + '!');
	fightHistory.push(rodName + '为' + group1[0].name + '的队伍召唤了' + familiarName + '!');
}
window.G['万圣节权杖'] = {name: '万圣节权杖', desc: '万圣节特典。召唤一只使魔史莱姆协同战斗！', groupModifier: rodSlimeGroupModifier, useCallback: useRodSlime};
const useRodGoblin = () => {
	const rodName = '哥布林王权杖';
	window.G.me.legacy = G[rodName];
	window.G.showDialog('装备遗物', '成功装备了' + rodName + '!');
}
State.variables.theClownInWoods = {
	name: '林中小丑', 
    exp: 200,
    max_hp: 200,
    hp: 200, 
    power: 20, 
    resistance: 20, 
    drops: [{
    	item: State.variables['万圣节权杖'], 
        chance: 1.0
    }]
}
const rodGoblinGroupModifier = (group1, group2, fightHistory) => {
	const rodName = '哥布林王权杖';
	const prototFightObj = State.variables.normalGoblin;
	const familiarName = '【使魔】哥布林';
	const spawned = fightObjectCopy(prototFightObj);
	spawned.name = familiarName;
	group1.push(spawned);
	console.log(rodName + '为' + group1[0].name + '的队伍召唤了' + familiarName + '!');
	fightHistory.push(rodName + '为' + group1[0].name + '的队伍召唤了' + familiarName + '!');
}
window.G['哥布林王权杖'] = {name: '哥布林王权杖', desc: '召唤一只哥布林协同战斗。', groupModifier: rodGoblinGroupModifier, useCallback: useRodGoblin};
// 2025.1.21 增加变异史莱姆
G.dirt = {name: '秽土', desc: '来自阿比斯的秽土，从僵尸怪身上掉落。僵尸怪大量在王国出没。'}
G.healer5EndTurnCallback = function (us, they, fightHistory = [], info = {}) {
	const per5Heal = Math.floor(info.me.max_hp * 0.05);
    fightHistory.push(`<span class="purple">复生者</span>为${info.me.name}回复了<span class="good">${per5Heal}</span>点血量!`);
    info.me.hp += per5Heal;
}
G.useHealer5 = () => {
	window.G.me.legacy = G.healer5;
	window.G.showDialog('装备遗物', '成功装备了' + G.healer5.name + '!');
}
G.healer5 = {name: '复生者', desc: '在自己的回合结束时回复5%的血量！', endTurnCallback: G.healer5EndTurnCallback, useCallback: G.useHealer5}; 
G.slimeZombie = {
	name: '僵尸史莱姆', 
    exp: 10,
    max_hp: 20,
    hp: 20, 
    power: 2, 
    resistance: 2, 
	legacy: G.healer5,
    drops: [{item: G.dirt, chance: 1, count: 2}]
}
<</script>>
<<script>>
    window.dd = State.variables
<</script>>


:: 前往窄门 {"position":"850,1650","size":"100,100"}
行刑室一角，一扇木门微微敞开。

“看来你已经可以看见东西了，”兜帽说。
你点点头。
兜帽身上披着的宽大风衣显得他个头很小，脸隐藏在帽沿的阴影之下。

“那就好，离开这里吧。那是一条通往行刑广场的密道，我们可以从那里逃走。”
……
兜帽注意到你的视线，沉默。
“你要在这里将我杀死？”说着这样的话，他的声音中却听不见一丝恐惧。

如果是“我”的话，会怎么做？
……

“你犹豫了，是你输了。”兜帽说。“走吧，让我们离开这里。”

[[穿过窄门]]


:: 半梦半醒 {"position":"1275,1775","size":"100,100"}
你当然知道这是什么，毕竟又不是失忆。
不过，也只是一些无足挂齿的小事罢了，这也是事实。 

<span class="orange">莫名其妙被选中</span>，加入勇者的小队，半年，试着接受他们的规矩，跟他们一起行动，然后看到这些无聊的东西，让人连回忆都懒得回忆。

事到如今怎么会看见这些场景呢？
可能是眼球失而复得的幻觉所致。
理所当然，毕竟眼睛离大脑那么近，看见什么都不奇怪。
新的眼睛只是两个廉价的玻璃珠子，看见这些无聊的场景也是理所当然。
可能有人爱看这些也说不定，那就让他们看去吧。
而我是时候该睁开眼睛了。

<<set $plotAfterKillEyeScooperRead to true>>

[[睁开眼睛->行刑室]]


:: 卡尔无头骑士 {"position":"1725,2300","size":"100,100"}
在视线的角落，一个黑影窜了出来，速度非常之快， 令人来不及思考。
必须立刻做出行动——[[挥动武器]]


:: 卡尔站了起来 {"position":"1975,2425","size":"100,100"}
“别以为这样就结束了。”
卡尔的声音从背后传来。

难以置信。
$me.name回过头去。

无头身躯把卡尔的头从地上捡起，抱在腰间。
而声音正是由那颗头颅发出。

“你真是怪物，”$me.name说。

“怪物？”卡尔嗤笑道，“这话轮得到你来说吗？<span class="orange">你不正是这样一路走过来的吗</span>？”

“[[这不是我期盼的]]”


:: 卢恩的催促 {"position":"1175,2550","size":"100,100"}
”怎么了？“卢恩看着$me.name说，”害怕去战斗吗？“
”怎么可能，“$me.name说。
”如果你不知道怎么用秽土净化者，去到不死王座你就知道了。“卢恩说。

[[离开->大墓地外围]]


:: 卢恩的真相 {"position":"2225,2550","size":"100,100"}
”他想说的无非是，<span class="orange">如果不死之王死了，瘴气消失，王国的军队就能进来搜集秽土，制造不死的士兵，征服世界</span>，“卢恩说。

”也就是说，勇者最初的目的，以及最终的目的，都是为了这个，并不是什么拯救世界之类的漂亮话，“卢恩说，”这，就是真相。“

”勇者……就是个笑话。“$me.name说。

”可是，<span class="orange">这不是不杀死不死之王的理由</span>，“卢恩说，”我说过了，我会告诉你更多。“

”什么意思？“

[[继续->杀死不死之王的理由]]


:: 去哪里找空气加湿器 {"position":"1050,2550","size":"100,100"}
”我研究室就有一台呢，要不要拿给你？”卢恩说。
“好的谢谢。”$me.name说。

“想得美！”卢恩说，“给你点提示吧，我的研究室在风暴山丘附近，那边的破布怪物会有大概10%的几率掉空气加湿器。”

[[返回->必要的东西]]


:: 去哪里找高射炮 {"position":"1050,2675","size":"100,100"}
“我听说死海旁边那艘大船里面有，你可以进去找找看，”卢恩说。

[[必要的东西]]


:: 史莱姆饲育场 {"position":"475,775","size":"100,100"}
<<set $slime.hp to $slime.max_hp>>\
<<set $slimeZombie.hp to $slime.max_hp>>\
=史莱姆饲育场=

一块圆形空地。
目力所及的地方有很多史莱姆。
哥布林们将它们当作食物饲养。

<<link "攻击史莱姆" "战斗画面">>\
	<<set $lastPassage to '史莱姆饲育场'>>\
	<<if random(100) < 30>>
		<<set $enemyNames to ['slimeZombie']>>\
	<<else>>
		<<set $enemyNames to ['slime']>>\
	<</if>>
<</link>>
<<link "同时攻击3只史莱姆" "战斗画面">>\
	<<set $lastPassage to '史莱姆饲育场'>>\
    <<silently>>\
    <<script>>
        const G = State.variables;
        // spawn slimes
        G.enemyNames = []
        for (let i = 0; i < 3; i++) {
			const enemyName = 'slime_' + i;
			let slimeCloned = null;
			if (Math.random() < 0.3){
				G.slimeZombie.legacy = null;
				slimeCloned = structuredClone(G.slimeZombie);
				slimeCloned.legacy = G.healer5; // 遗物有回调，没法克隆
				G.slimeZombie.legacy = G.healer5;
			} else {
				slimeCloned = structuredClone(G.slime);
			}
            slimeCloned.name = `${slimeCloned.name}`;
            G[enemyName] = slimeCloned;
            G.enemyNames.push(enemyName);
        }
    <</script>>
    <</silently>>\
<</link>>

返回[[哥布林巢穴裂缝]]


:: 向小丑搭话 {"position":"475,650","size":"100,100"}
<<silently>>
<<script>>
let G = State.variables;
G.maskCount = getItem(G.inventory.items, '小丑面具')?.count || 0;
G.slimeRodCount = getItem(G.inventory.items, '万圣节权杖')?.count || 0;
G.dirtCount = getItem(G.inventory.items, '秽土')?.count || 0;
<</script>>
<</silently>>

“嘻嘻……嘻嘻嘻”

<div class="aa">
{{{
          ___
         /\  \
        /  \/ \
   ___  \   O /  ___
  /    \ \   / /    \
 /   __ -    -  __   \
/___/ | <>   <> | \___\
O  ___|    ^    |___  O
 /     \  -^-  /    \
/   /\  \_____/ /\   \
\_ / /          \ \_ /
O   /   /\   /\  \  O
     \ /  \ /  \ /
      O    O    O
}}}
</div>

“有人寻找灵魂，有人找寻面具，
如果你能带给我3个面具，也许我会给你一份礼物。”

<<if $slimeRodCount < 1>>
* 小丑面具 ($maskCount/3) <<print (($maskCount >= 3) ? '✅' : '❌');>>
<<if $maskCount >= 3>>>\
	<<link "🟢换取万圣节礼物" "向小丑搭话">>
    	<<silently>>
    	<<script>>
        reduceItemCount(G.inventory.items, '小丑面具', 3);
		addItem(G.inventory.items, G['万圣节权杖'], 1);
        G.showDialog('获得物品', '获得了' + State.variables['万圣节权杖'].name + '!');
        <</script>>
        <</silently>>\
    <</link>>
<</if>>
<</if>>
<<if $slimeRodCount > 0 and $rodSlimeLevel < 10>>\
	万圣节权杖等级: $rodSlimeLevel (升级后增加使魔的属性，等级上限为10)
	* 秽土 ($dirtCount/10) <<print (($dirtCount >= 10) ? '✅' : '❌');>>
	<<if $dirtCount >= 10>>\
	<<link "🟢升级万圣节权杖" "向小丑搭话">>
    	<<silently>>
    	<<script>>
        reduceItemCount(G.inventory.items, '秽土', 10);
		G.rodSlimeLevel += 1;
        G.showDialog('升级遗物', `万圣节权杖升到了等级${G.rodSlimeLevel}!`);
        <</script>>
        <</silently>>\
    <</link>>
	<</if>>
<</if>>
[[返回->低矮林地]]


:: 向穿墙者搭话 {"position":"475,900","size":"100,100"}
该说那是一个人吗，事实上只是两条腿而已。
不过可以想象这样的情形：一个人直挺挺站着，上半身完全没入岩石之中。

发出声音，试图吸引那个东西的注意。

“有人在那里？”那个东西问道，一个男人的声音。
是我能够理解的语言。
于是我给了它肯定的答复。

“这是什么地方？”
哥布林巢穴，我说。

沉默。
“哪个国家的哪个方位？”那东西继续问。

“[[你能不能先从那里出来]]？”


:: 向老头搭话 {"position":"550,375","size":"100,100"}
老头：“<span class='good'>$me.name</span>，今天是你的成年日。可你别以为成年就可以为所欲为了。为了防止你祸害良家女孩和这个世界，我要限制你的人身自由。”
老头：“什么时候能还你自由？<span class="orange">只要我还活着，你就别想了</span>。”

<div class="aa">
{{{
                       ,---.
                       /    |
                      /     |
                     /      |
                    /       |
               ___,'        |
             <  -'          :
              `-.__..--'``-,_\_
                 |o/ ` :,.)_`>
                 :/ `     ||/)
                 (_.).__,-` |\
                 /( `.``   `| :
                 \'`-.)  `  ; ;
                 | `       /-<
                 |     `  /   `.
 ,-_-..____     /|  `    :__..-'\
/,'-.__\\  ``-./ :`      ;       \
`\ `\  `\\  \ :  (   `  /  ,   `. \
  \` \   \\   |  | `   :  :     .\ \
   \ `\_  ))  :  ;     |  |      ): :
  (`-.-'\ ||  |\ \   ` ;  ;       | |
   \-_   `;;._   ( `  /  /_       | |
    `-.-.// ,'`-._\__/_,'         ; |
       \:: :     /     `     ,   /  |
        || |    (        ,' /   /   |
        ||                ,'   / SSt|
}}}
</div>


[[老头的任务]]
[[返回->大厅]]


:: 听哥布林王说话 {"position":"900,1025","size":"100,100"}
哥布林王用嘶哑，走调的<span class='important'>王国公用语</span>开口说话了：

“你想要胜利的证明——我把这柄权杖给你，拿上它离开，别再回来。”
哥布林会王国公用语已经足够令人吃惊了，可是更加令我惊讶的是，它好像要放我离开。

“为什么？”
“你知道为什么，”哥布林王说，“却假装不知道。”
这句话让我感到莫名的恼火。
“你对身处此处的我有什么不满么？你们是哥布林，我是人类。讨伐你们是理所当然的。”
哥布林骑士们眼露凶光，看起来恨不得把我撕碎。
但是哥布林王抬抬手，制住它们。
“这只是一个交易，我希望你能接受。”

到做选择的时候了:
[[“我明白了，我会离开，把东西给我”]]。
[["我会杀了你，然后把东西带走"]]。


:: 和卡尔战斗之后 {"position":"850,1900","size":"100,100"}
<<if $karl.hp < 1>><<goto '击败卡尔剧情'>><</if>>\
=战败=

“靠幸运被选中的家伙，终归只有这点实力吗，”卡尔说着，将染血的喋血者插入地面，”索尔坦那家伙，居然被你杀掉，真是有够好笑。“

兜帽跑过来观察你的伤势，沉默了一下，小声说到，”看来不需要治疗呢。“
但还是发动了微弱的治疗魔法，以骗过卡尔的眼睛。

”你这家伙，“卡尔眯了眯眼睛，说，”什么时候多了个同伴？还是治疗师，<span class="orange">是想把她当成梅利的替代吗</span>？“
沉默。
”算了，这一切都是命运的安排，我命中注定成为最后的勇者，“卡尔说，”走吧，我不会在这里处决你，到行刑场去。——戴兜帽的家伙，我不知道你怎么溜进来的，不过我劝你还是离他远一点，他是个疯子。“

”说这样冠冕堂皇的话，你自己又算得上是什么东西呢？“兜帽说。
”哦？你又知道我的什么？“
”我全都知道，透过$me.name的眼睛，全都看到了“，兜帽抬起脸来，右眼散发出微弱的，令人怀念的光芒。你马上明白了，那正是你的眼睛。
”索尔坦是个人渣，而你只是他的狗而已。“兜帽毫不留情地说。

[[……->和卡尔战斗之后2]]


:: 和卡尔战斗之后2 {"position":"850,2025","size":"100,100"}
”住口！“卡尔挥动巨剑猛地砍下，在地上凿出个深坑。
”全他妈是蠢货，你也是他们也是，连索尔坦为什么这样做都不知道，就擅自把他贬为恶人……”卡尔的脸色阴沉，“如果你们知道他这样做是为了拯救所有人，你还能说出这样的话吗！？“
”<span class="orange">我只要知道你们对梅利做的事情就够了</span>。“兜帽说。
沉默。
”你是……”卡尔目不转睛地盯着兜帽，说“那时候的……我想起来了，梅利的妹妹。“

卡尔稍稍向前探出身子，说，”我不知道你看了什么，我没想伤害梅利。索尔坦确实太过粗鲁了，可是他那时正在气头上……比起这个，是$me.name杀死了梅利，你怎么还帮着他！？“
”他和你们不一样，“兜帽说，”<span class="orange">他所做的一切都会被重构成正确的样子</span>。“
“你在说些什么…”卡尔脸色变得更加阴沉了。

半晌，卡尔转过身去，”走吧，先离开这里。“
”什么意思？”兜帽狐疑地问到。
“我会听你们的说辞，不过得先离开这里，在<span class="orange">骑士团</span>抵达之前。”

[[跟上卡尔]]


:: 哥布林前哨站 {"position":"750,775","size":"100,100"}
<<set $normalGoblin.hp to $normalGoblin.max_hp>>\
<<set $zombieGoblin.hp to $zombieGoblin.max_hp>>\
=哥布林前哨站=

一个黑乎乎的洞口通往[[巢穴深处]]。

洞口外边稍微开阔一点的地方，四处站着一些无所事事的哥布林。
在黑暗的掩盖下，我们可以
<<link "攻击哥布林" "战斗画面">>
    <<if random(100) < 30>>
		<<set $enemyNames to ['zombieGoblin']>>\
	<<else>>
		<<set $enemyNames to ['normalGoblin']>>\
	<</if>>
	<<set $lastPassage to '哥布林前哨站'>>\
<</link>>而不会引起骚乱。
<<link "同时攻击3只哥布林" "战斗画面">>\
	<<set $lastPassage to '哥布林前哨站'>>\
    <<silently>>\
    <<script>>
        const G = State.variables;
        // spawn goblins
        G.enemyNames = []
        for (let i = 0; i < 3; i++) {
            const enemyName = 'goblin_' + i;
            let goblinCloned = null;
            if (Math.random() < 0.3){
				G.zombieGoblin.legacy = null;
				goblinCloned = structuredClone(G.zombieGoblin);
				goblinCloned.legacy = G.healer5; // 遗物有回调，没法克隆
				G.zombieGoblin.legacy = G.healer5;
			} else {
				const temp = G.normalGoblin.drops;
				G.normalGoblin.drops = null;
				goblinCloned = structuredClone(G.normalGoblin);
				G.normalGoblin.drops = temp;
				goblinCloned.drops = temp;
			}
            G[enemyName] = goblinCloned;
            G.enemyNames.push(enemyName);
        }
    <</script>>
    <</silently>>\
<</link>>

地上躺着死去的同伴们的尸体。
仔细看的话能够发现，[[梅利的尸体在发光]]。

[[躲进岩石裂缝->哥布林巢穴裂缝]]
<<if $theGoblinKing.hp <= 0>>
🟢风风光光地[[离开哥布林巢穴]]
<</if>>


:: 哥布林巢穴裂缝 {"position":"600,775","size":"100,100"}
=狭窄的岩石裂缝=

昏暗的洞穴，空气中漂浮着腐肉和粪便的味道。

<<if not $consideredInCave>>
[[思考我现在应该做的事情]]
<<else>>
裂缝深处通往[[史莱姆饲育场]]
岩石裂缝外边就是[[哥布林前哨站]]
<<if $theWallPenetrator.hp > 0 and $wallPenetratorTalked is false and random(100) < 100>>\
🟠如果我没看错的话，岩石长出来两条腿。[[向两条腿搭话->向穿墙者搭话]]
<</if>>\
<</if>>\
<<audio "golden_season" loop play>>


:: 地下监牢 {"position":"1125,1400","size":"100,100"}
<<set $normalGoblin.hp to $normalGoblin.max_hp>>\
<<set $zombieGoblin.hp to $zombieGoblin.max_hp>>\
=地下监牢=

关押弱小魔物的地下监牢。
”都是些哥布林，“兜帽说。

<<link "攻击哥布林" "战斗画面">>
    <<if random(100) < 30>>
		<<set $enemyNames to ['zombieGoblin']>>\
	<<else>>
		<<set $enemyNames to ['normalGoblin']>>\
	<</if>>
	<<set $lastPassage to '地下监牢'>>\
<</link>>
<<link "同时攻击3只哥布林" "战斗画面">>\
	<<set $lastPassage to '地下监牢'>>\
    <<silently>>\
    <<script>>
        const G = State.variables;
        // spawn goblins
        G.enemyNames = []
        for (let i = 0; i < 3; i++) {
            const enemyName = 'goblin_' + i;
            let goblinCloned = null;
            if (Math.random() < 0.3){
				G.zombieGoblin.legacy = null;
				goblinCloned = structuredClone(G.zombieGoblin);
				goblinCloned.legacy = G.healer5; // 遗物有回调，没法克隆
				G.zombieGoblin.legacy = G.healer5;
			} else {
				const temp = G.normalGoblin.drops;
				G.normalGoblin.drops = null;
				goblinCloned = structuredClone(G.normalGoblin);
				G.normalGoblin.drops = temp;
				goblinCloned.drops = temp;
			}
            G[enemyName] = goblinCloned;
            G.enemyNames.push(enemyName);
        }
    <</script>>
    <</silently>>\
<</link>>

返回[[第三巡逻点]]


:: 地底大空洞 {"position":"850,1775","size":"100,100"}
=地底大空洞=

石头通道的尽头，空旷，黑暗的空间。
待眼睛适应那黑暗，
便发现在那无限绵密的黑暗之中，一缕银光从顶端的开口洒落，
在那微弱的光芒之中，是一条长长的木梯。
木梯无依无靠，径直从那顶端插入地面，
在这过分宽广的空间中，就像是蜘蛛之丝一样脆弱。

“走吧，”兜帽说，“爬上那条木梯，就是行刑广场了。”

“之后我们去哪里？”

“是呢，”兜帽说，“<span class="orange">去一个更加真实的地方怎么样</span>？”说完便迈出脚步。

[[跟上->遭遇卡尔和军队]]


:: 大厅 {"position":"700,375","size":"100,100"}
=大厅=

老旧木头房子的客厅。
从这里可以前往[[小屋前十字路口]]，[[起居室]]和[[老头的房间]]。

如果想要休息的话，我需要先返回起居室。

<<if $oldMan.hp > 0>>
客厅中央站着一个$oldMan.name。\
<<link "攻击" "战斗画面">>
	<<set $lastPassage to '大厅'>>\
    <<script>>State.variables.enemyNames = ['oldMan'];<</script>>
<</link>>
[[向老头搭话]]
<<else>>
客厅中央躺着$oldMan.name的尸体。
🟢现在，我可以从小屋前面的十字路口离开。
<</if>>


:: 大墓地外围 {"position":"1300,2300","size":"100,100"}
=大墓地外围=

环顾四周，眼中所见是绵延不绝的墓碑的海洋。

抬头，看不见天空。
种种迹象表明身处洞穴内部。
但是这洞穴未免又太过巨大，目力所及之处见不到墙壁，而只能看见穹顶。
爬满穹顶的发光植物为整个空间提供了微弱，如同阴雨天气一般的照明。

<<if not $talkedToRune>>\
[[身后传来脚步声]]
<<else>>\
[[与卢恩交谈]]
前往东边的[[低矮墓地]]
前往南边的[[风暴山丘]]
前往西边的[[死海]]
或者前往北边的[[不死王座]]
<</if>>
<<if $testing>>
[[测试用代码]]
<</if>>
<<audio "big_grave" loop play>>\


:: 大监狱304室 {"position":"600,1400","size":"100,100"}
=大监狱304室=

空气中漂浮着莫名的臭味，偶尔能听见不知哪儿传来的遥远哀嚎。
由于失去了双眼，我什么都看不见，但现在大概是深夜。

[[思考人生的意义]]
<<silently>>\
<<audio ":all" stop>>
<<audio "big_prison" loop play>>
<</silently>>\


:: 守墓人 {"position":"975,2150","size":"100,100"}
“那是守墓人，”兜帽说，“地下世界的引路人。”

眼看着守墓人将十字架用右手托住，高高举起，展示出投掷的姿态。
当意识到它要做什么的时候——糟糕了，你不禁这样想——已经躲不掉了。

“你会找到真相的，”兜帽说。
然后你感到身体腾空，兜帽用全身的力气把你撞开。
破空之声传来，感受到强劲的气流。
咚的一声，碗口粗的木头把兜帽的胸脯刺穿，倾斜着把她钉在黑色柔软的土地上。
大量的红色液体从她的胸口，还有嘴角汩汩流出。

啊，没救了，你想。
还没来得及发出感慨，守墓人便朝你走了过来，伴随着沉重的脚步声，你挣扎着爬起，却被他一脚踢飞。
内脏大量破损——致命伤。
但是没关系，<span class="orange">只要重新来过就好了</span>，于是你又站了起来。
可是还没等你站起，你便感到失重——守墓人用巨手将你抓起，狠狠地往地面拍去。
这一击就没有那么好受了，你的五脏六腑和脑浆喷洒了一地。

[[……->第四章]]


:: 对了，他是…… {"position":"1425,2550","size":"100,100"}
”怪人卢恩？“
”是天才学者卢恩！“
对，在哥布林巢穴见过他来着。

”你怎么会在这里？“
”我已经在这里研究很久了，在认识你之前。“
”这究竟是什么地方？“

”正如你所见，”卢恩说，“人们把它称为<span class="orange">大坟墓</span>。”

你沉默片刻，认为当务之急是从这个不详的地方离开。
[[向卢恩询问离开的方法->离开的方法]]


:: 对了，是那个…… {"position":"1175,2925","size":"100,100"}
你幡然醒悟：“秽土。复活的关键是秽土。”
卢恩点点头，说，“没错，秽土。它们是没有灵魂的秽土。“
”它们？“
卢恩说，“你在外面的世界也见过僵尸吧，它们本质上和不死之王是一样的。”

”可是僵尸被打倒之后不会复活。“
”那是因为大坟墓以外的地方秽土不足，“卢恩说，”而且也不是每个僵尸都有死者之王那么强的恢复力。不死之王是特别的。只要击败他……“
”只要击败他？“
“没什么，只是自言自语罢了，”卢恩换了个话题，“我就直接告诉你答案吧，要阻止它复活，需要大量的灵魂。将灵魂溶液洒满死者之王周遭的土地，就能够将其净化，而复活自然也会被阻止。”
“……听起来不是那么轻松的工作。”
“我会帮你，”卢恩说，“不过你得给我准备好一些必要的东西。”

[[必要的东西]]

<<silently>>
<<script>>
let G = State.variables;
G.talkedToRune = true;
<</script>>
<</silently>>


:: 对峙卢恩 {"position":"2100,2675","size":"100,100"}
”卢恩……你做了什么。“

来者是卢恩。
他掷出匕首，杀死了卡尔。

”别急别急，“卢恩说，”他没说完的，我可以告诉你更多。“

”你究竟有什么居心。“

”我能有什么居心？“卢恩说，”我向你保证，我说的句句属实，需要我对天发誓天打雷劈吗？“

[[……->卢恩的真相]]


:: 小屋前十字路口 {"position":"725,525","size":"100,100"}
=小屋前十字路口=

<div class="aa">
{{{
                 ___                          (_)
               _/XXX\
_             /XXXXXX\_                                    __
X\__    __   /X XXXX XX\                          _       /XX\__      ___
    \__/  \_/__       \ \                       _/X\__   /XX XXX\____/XXX\
  \  ___   \/  \_      \ \               __   _/      \_/  _/  -   __  -  \__/
 ___/   \__/   \ \__     \\__           /  \_//  _ _ \  \     __  /  \____//
/  __    \  /     \ \_   _//_\___     _/    //           \___/  \/     __/
__/_______\________\__\_/________\_ _/_____/_____________/_______\____/_______
                                  /|\
                                 / | \
                                /  |  \
                               /   |   \
                              /    |    \
                             /     |     \
                            /      |      \
                           /       |       \
                          /        |        \
                         /         |         \
}}}
</div>

从这里可以看见破烂的[[小屋->大厅]]，和小屋背后的[[低矮林地]]。

大马路如此笔直，它一定可以带我去往任何地方。

<<if $oldMan.hp < 1>>
🟢是时候[[离开这里]]了。
<<else>>
[[偷偷溜走]]
<</if>>


:: 巢穴深处 {"position":"900,775","size":"100,100"}
=<<print passage()>>=

哥布林巢穴深处，莫名的腐臭更加严重了。

<<if $theOutpostMountainGoblin.hp > 0>>\
一只拿着火把的<span class='red'>大块头哥布林</span>在巡逻。<<link "攻击大个子哥布林" "战斗画面">>
	<<set $lastPassage to '巢穴深处'>>\
    <<set $enemyNames to ['theOutpostMountainGoblin']>>\
<</link>>\
<<else>>\
地上躺着大块头哥布林的尸体。
🟢现在我可以前往[[祭坛]]，[[王之间]]。
<</if>>

返回[[哥布林前哨站]]。


:: 开口说话 {"position":"1850,2425","size":"100,100"}
偷袭者面无表情地蹲下，将被斩断的手腕拾起，接上。
然后握住拳头，张开，目不转睛地看着，像是在欣赏一件艺术品。

“卡尔……”

没错，那无疑是卡尔。
但是他似乎有些不太对劲，正常人的手臂断了能够接上吗？
除非他已经变成了僵尸。

$me.name不由得加强了戒备。

[[继续->我是不死之王的骑士]]


:: 必要的东西 {"position":"1175,2675","size":"100,100"}
<<silently>>
<<script>>
let G = State.variables;
G.soulsCount = getItem(G.inventory.items, '等待回收的灵魂')?.count || 0;
G.silverIodideCount = getItem(G.inventory.items, '碘化银粉末')?.count || 0;
G.airHumidifierCount = getItem(G.inventory.items, '空气加湿器')?.count || 0; 
G.cannonCount = getItem(G.inventory.items, '高射炮')?.count || 0; 
G.cannonBallCount = getItem(G.inventory.items, '加农炮弹')?.count || 0; 
G.taskMakeRainsComplete = G.soulsCount >= 100 && G.silverIodideCount >= 100 && G.airHumidifierCount >= 1 && G.cannonCount >= 1 && G.cannonBallCount >= 10;
<</script>>
<</silently>>\
卢恩列出的物品清单如下：

* 等待回收的灵魂 ($soulsCount/100) <<print (($soulsCount >= 100) ? '✅' : '❌');>>
* 空气加湿器 ($airHumidifierCount/1) <<print (($airHumidifierCount >= 1) ? '✅' : '❌');>>
* 碘化银粉末 ($silverIodideCount/100) <<print (($silverIodideCount >= 100) ? '✅' : '❌');>>
* 高射炮 ($cannonCount/1) <<print (($cannonCount >= 1) ? '✅' : '❌');>>
* 炮弹 ($cannonBallCount/10) <<print (($cannonBallCount >= 10) ? '✅' : '❌');>>

<<if not $taskMakeRainsComplete>>
“准备好材料再来找我，”卢恩说。
<<else>>
“看来你已经准备好了，”卢恩说。
🟠[[获取对付不死之王的道具]]
<</if>>

[[去哪里找空气加湿器]]
[[去哪里找高射炮]]
[[离开->大墓地外围]]


:: 怎样击败不死者之王？ {"position":"1300,2675","size":"100,100"}
“怎样才能击败不死者之王？”$me.name问。
“要想知道怎么做，首先要理解为什么做不到，”卢恩说，“为什么你无法击败不死者之王？”

答案显而易见。
“<span class="orange">因为它会复活</span>。”$me.name说。

“没错，名字不会骗人，”卢恩说，“可是，为什么它能复活？”
”就是因为不知道，我才会问你。“

啧啧啧，卢恩摇摇头，说，”这可不行啊，和蠢人打交道不符合我的美学，毕竟我可是天才学者。“
令人火大的家伙。

”我再问你一次， 为什么不死者之王能够复活？“卢恩说。

[[“你去问不死者之王吧！“]]
[["因为你没有母亲。"]]
[[击败不死之王的提示]]


:: 思考人生的意义 {"position":"725,1400","size":"100,100"}
我没有记忆，对于过去的自己一无所知。
而有记忆的时间太短，以至于几乎没有活着的实感。

不仅是自己的生命，有时我觉得这个世界并不真实——就像那天在哥布林巢穴看见的景象那样。
可是生活在这个世界的人们，难道没有一丁点价值吗？
不……
他们有自己的生活，有自己的欲望。
和我怎么想没有关系，他们的生命有真实的重量。

”那你为什么要将他们杀死呢？“
每个人都这样问我。
而现在的我只能给出这样的答案：<span class="orange">因为我比任何人都要自由，而维护这样的自由，难道不是我的使命吗？</span>

如果这个世界是虚构的，那它的作者一定是个天才。他赋予我的使命就是背叛，背叛，不停地背叛，然后死去，甚至连感情线都没有给我安排，多么波澜壮阔的一生！
所以我要做的就是，在这里死去，再一次背叛所有人的期待。

[[自杀]]


:: 思考我现在应该做的事情 {"position":"600,900","size":"100,100"}
选择永远只有两种，前进，或者是后退。

如今<span class="orange">付出了惨重的代价</span>，我已经失去了后退的选项。
我必须取下哥布林王的头颅，以此凭吊死去的队友们。

[[返回->哥布林巢穴裂缝]]
<<script>>
State.variables.consideredInCave = true;
<</script>>


:: 我是不死之王的骑士 {"position":"1850,2550","size":"100,100"}
“索尔坦是对的。”

令人意外的是，卡尔开口说话了。
看来他并非失去理智的僵尸。
“但是他死得太草率，没能得知真相。”卡尔说。

他究竟在说些什么呢？虽然不明所以，姑且回他一句吧。
“真相？”

卡尔不语，抬起右臂，手中长剑直指$me.name。
“不死之王的骑士，参上！”话音刚落，卡尔猛然向$me.name逼近。

<<link "🔴进入战斗" "战斗画面">>\
	<<set $karlTheReviver.hp to $karlTheReviver.max_hp>>\
	<<set $lastPassage to "击败卡尔复生者">>\
    <<set $enemyNames to ['karlTheReviver']>>\
<</link>>\


:: 战斗画面 {"position":"1000,225","size":"100,100"}
=战斗=
<<silently>>\
<<script>>
console.log('Second check');
const enemies = State.variables.enemyNames.map(name => State.variables[name]);
const isGroupAlive = group => group.some(obj => obj.hp > 0);
State.variables.enemyNameString = ''
enemies.map(obj => State.variables.enemyNameString += obj.name + ' ')
if (!isGroupAlive(enemies)){
	console.log('Enemies All Dead!');
    State.variables.error = true;
}else{
	State.variables.error = false;
	// 处理主角的power和resistance
	const me = State.variables.me;
	me.power = me.intrinsicPower + me.weapon.power;
	me.resistance = me.intrinsicResistance + me.armor.resistance;
	const us = [me];
	const usCopy = us.map(dd => fightObjectCopy(dd));
	// 处理敌人的objCopy
    const enemiesCopy = enemies.map(enemy => fightObjectCopy(enemy));
	// 2024.10.21 增加指环效果
	const cb = {'g1': {}, 'g2': {}};
	for (let i = 0; i < us.length; i++){
		const ally = us[i];
		if (ally.legacy){
			cb['g1'][i] = {}
			if (ally.legacy.damageCalculator){
				cb['g1'][i]['damageCalculator'] = ally.legacy.damageCalculator;
			}
			if (ally.legacy.groupModifier){
				cb['g1'][i]['groupModifier'] = ally.legacy.groupModifier;
			}
			if (ally.legacy.deadCallback){
				cb['g1'][i]['deadCallback'] = ally.legacy.deadCallback;
			}
			// 2024.11.19 增加伤害减缓器
			if (ally.legacy.damageReductor){
				cb['g1'][i]['damageReductor'] = ally.legacy.damageReductor;
			}
			// 2025.01.20 增加回合结束回调
			if (ally.legacy.endTurnCallback){
				cb['g1'][i]['endTurnCallback'] = ally.legacy.endTurnCallback;
			}
		}
	}
	// 2024.10.27 循环为敌人设置callback函数
	for (let i = 0; i < enemies.length; i++){
		const enemy = enemies[i];
		if (enemy.legacy){
			cb['g2'][i] = {}
			if (enemy.legacy.damageCalculator){
				cb['g2'][i]['damageCalculator'] = enemy.legacy.damageCalculator;
				console.log('为'+enemy.name+'设置了伤害计算回调!');
			}
			if (enemy.legacy.groupModifier){
				cb['g2'][i]['groupModifier'] = enemy.legacy.groupModifier;
				console.log('为'+enemy.name+'设置了组回调!')
			}
			if (enemy.legacy.deadCallback){
				cb['g2'][i]['deadCallback'] = enemy.legacy.deadCallback;
				console.log('为'+enemy.name+'设置了死亡回调!')
			}
			// 2024.11.19 增加伤害减缓器
			if (enemy.legacy.damageReductor){
				cb['g2'][i]['damageReductor'] = enemy.legacy.damageReductor;
			}
			// 2025.01.20 增加回合结束回调
			if (enemy.legacy.endTurnCallback){
				cb['g2'][i]['endTurnCallback'] = enemy.legacy.endTurnCallback;
			}
		}
	}
	const fightHistory = groupFight(usCopy, enemiesCopy, cb);
    // Added 2024.10.27 merge battle log.
    const neetFightHistory = window.mergeBattleLogs(fightHistory);
	State.variables.fightHistory = neetFightHistory; // 用于后续展示记录
	State.variables.fightHistoryHtml = neetFightHistory.join('\n')
	window.temp = neetFightHistory;
	// console.log(fightHistory);
	State.variables.me.hp = usCopy[0].hp;
    for (let i = 0; i < enemies.length; i++) {
        enemies[i].hp = enemiesCopy[i].hp;
    }
    console.log(enemies[0])
	State.variables.enemy = enemies[0];  //考虑到兼容性问题
}
<</script>>
<</silently>>\

<<if $error>>\
	$enemyNameString已经死了，请不要反复鞭尸！
<<else>>\
向$enemyNameString发起了攻击！
<<if $me.hp < 1>>\
<<goto "死亡">>\
<<else>>\

<div>$fightHistoryHtml</div>

<span class='good'>$enemyNameString被你杀死了！</span>
<<include '物品掉落'>>
<<include '杀死怪物回调'>>
<!--<<button "查看战斗记录">><<set _temp to $showDialogFightHistory()>><</button>>-->
<</if>>\
<</if>>\

<<link "返回" $lastPassage>><</link>>


:: 挥动武器 {"position":"1850,2300","size":"100,100"}
传来切开什么东西的触感。

偷袭者向后跳开。

[[……->开口说话]]


:: 接受亚哈船长的招待 {"position":"1475,2025","size":"100,100"}
<<script>>
const G = State.variables;
G.haveTicket = checkHavingItem(G.inventory.items, '亚哈船长的招待券');
<</script>>
<<if not $haveTicket>><<goto '死海'>><</if>>\
=亚哈船长的招待=

头戴船长帽的独眼骷髅拄着一根比人还高的不知道什么东西，
静静等待着你做出选择。

<<link "发起攻击" "战斗画面">>
	<<set $lastPassage to passage()>>
    <<set $captain.hp to $captain.max_hp>>
    <<set $enemyNames to ['captain']>>
    <<script>>reduceItemCount(State.variables.inventory.items, '亚哈船长的招待券', 1);<</script>>
<</link>>
[[死海]]


:: 杀人者 {"position":"475,1400","size":"100,100"}
法官：既然如此，请你具体说明自己的作案动机。坦诚相告对量刑有好处。
于是我说：我还杀了养育我的老头，那之后忘了收拾，尸体就摆在地上。现在天气那么热，希望房间别被弄的太臭。
当他们好不容易理解了我的意思——“这种人是怎么成为勇者的！”终于有人忍不住站起来对我怒吼。
这就是坦诚相告的结果吗？

就这样我被<span class='red'>剜掉双眼</span>，关进大牢，等待三天后的绞刑。

[[大监狱304室]]


:: 杀死不死之王的理由 {"position":"2225,2425","size":"100,100"}
”很简单，杀死那个骷髅之后，把秽土全部净化就可以了，“卢恩说——
”难道你想和不死之王在这个墓穴里待一辈子吗，你想代替那家伙，当不死之王的骑士？“

”全部净化……做得到吗？“

”当然，“卢恩说，”<span class="orange">只要我们两个一起努力，没有什么是做不到的</span>。“

卢恩说的确实有道理，毕竟不能永远待在这里。

”好了，去完成你作为勇者，最后的使命吧。“

[[重新面对不死者之王->不死王座]]


:: 杀死剜眼者后剧情 {"position":"1125,1525","size":"100,100"}
杀死剜眼者给你一种从未有过的奇妙感觉，就像是找回了丢失掉很久的宝物那样的感觉。
但是你没能沉浸在这余韵中很久。

“你的眼睛已经失去了，失去的东西毕竟再也找不回来。”兜帽说，“我在地上捡到两个玻璃球，你就先装上它们吧。”
放到你掌心，两个冰凉的玻璃球。
“擦干净了吗？”
”……“

大小形状刚刚好——也许有些圆过头了——可是为什么不呢，总比没有眼球好。
于是你把它们塞进自己的眼眶，一阵钝痛过后，你看见了一些东西。

[[一些东西]]

<<silently>>\
<<script>>
	const G = State.variables;
	addItem(G.inventory.items, G.glassEyeBall);
    G.showDialog('获得物品', '获得了' + G.glassEyeBall.name + '!');
<</script>>
<</silently>>\


:: 杀死怪物回调 {"position":"1250,425","size":"100,100"}
<<silently>>\
<<script>>
const G = State.variables;
G.enemyNames.map(varName => {
	G.addExp(G[varName].exp);
    if (varName.startsWith('slime')){
        console.log('杀死史莱姆')
        addItem(State.variables.titles.items, State.variables.slimeSlayer, 1)
    }else if (varName == 'oldMan'){
        console.log('杀死老头')
        if (!checkHavingItem(State.variables.titles.items, '俄狄浦斯')){
            addItem(State.variables.titles.items, State.variables.oldManSlayer)
        }
    }else if (varName == 'theOutpostMountainGoblin'){
        if (!State.variables.me.legacy || State.variables.me.legacy.name != '破甲指环'){
            console.log('不使用破甲戒指击破山岭哥布林');
            const title = {name: '手撕重坦者', desc: '不使用破甲戒指击破前哨站的山岭哥布林。'}
            addItem(State.variables.titles.items, title)
        }else{
            const title = {name: '封弊者', desc: '使用破甲戒指击破前哨站的山岭哥布林。'}
            addItem(State.variables.titles.items, title);
        }
        console.log('杀死前哨站的山岭哥布林');
    }else if (varName == 'theGoblinKing'){
        if (!State.variables.me.goblinKingTalked){
            console.log('背信弃义者');
            const title = {name: '背信弃义者', desc: '你的良心不会痛吗？'}
            addItem(State.variables.titles.items, title)
        }else{
            const title = {name: '战斗狂', desc: '杀死哥布林王。'}
            addItem(State.variables.titles.items, title);
        }
        console.log('杀死哥布林王');
    }else if (varName == 'theWallPenetrator'){
    	const title = {name: '趁人之危', desc: '杀死不明所以的穿墙者。'}
        addItem(State.variables.titles.items, title);
    }else if (varName == 'theRouletteEscort'){
    	const title = {name: '赌狗', desc: '杀死哥布林轮盘搀扶者。'}
        addItem(State.variables.titles.items, title);
        G.rouletteLevel = 1;
    }
})
<</script>>
<</silently>>\


:: 梅利的尸体在发光 {"position":"750,900","size":"100,100"}
梅利是我们队伍中的牧师。
她给自己施加了诅咒，一旦死亡就会近乎永久地为四周施加治疗光环。
如果稍微靠近就能够回复健康。

<<link "使用梅利进行治疗" "梅利的尸体在发光">><<set $temp to $healMySelf(0.05)>><</link>>
[[返回->哥布林前哨站]]


:: 死亡 {"position":"1125,250","size":"100,100"}
<<silent>>
<<script>>
console.log('回复怪物的血量');
const enemies = State.variables.enemyNames.map(name => State.variables[name]);
enemies.map(obj => {obj.hp = obj.max_hp});
<</script>>
<</silent>>\
=死亡=

<span class='danger'>你被$enemy.name杀死了！</span>
$enemy.name的HP余量: <meter @value="$enemy.hp" min="0" @max="$enemy.max_hp"></meter>

<span class='important'>你必须活下来。</span>

<!--<<button "查看战斗记录">><<set _temp to $showDialogFightHistory()>><</button>>-->
<div>$fightHistoryHtml</div>

<<button "满血复活（使用禁忌的时间回溯魔法）">>\
<<set _deadMark to {name: '死神的印记', desc: '继续你的旅途，这双眼睛会注视着你'}>>\
<<set _temp to addItem($inventory.items, _deadMark)>>\
<<set $me.hp to $me.max_hp>>\
<<goto $lastPassage>>\
<</button>>

或者你也可以通过侧边栏重新开始游戏。


:: 死海 {"position":"1475,2175","size":"100,100"}
<<script>>window.G = State.variables;<</script>>\
=死海=

风暴山丘旁边的谷地。
底部是一片沼地，灌满了黑色的浓稠泥浆。
散发恶臭，咕嘟咕嘟地冒着泡。
到处散落着不知名生物的骸骨。

靠近岸边的地方，停靠着一艘搁浅大船——的残骸。
<<script>>G.haveTicket = checkHavingItem(G.inventory.items, '亚哈船长的招待券');<</script>>\
<<if $haveTicket>>🟠[[接受亚哈船长的招待]]<</if>>

船骸旁边，一些人形的东西在没过膝盖的泥浆中缓步行走，看起来只是在无目的地徘徊。
仔细望去，那是一些身上披着破布的骷髅，有些身上还残留着腐肉。
<<link "发起攻击" "战斗画面">>
	<<set $lastPassage to passage()>>
    <<set $sailor.hp to $sailor.max_hp>>
    <<set $enemyNames to ['sailor']>>
<</link>>

乌鸦似的生物在岸边张牙舞爪的黑色枯树上大量聚集，一声不响。

<<if random(100) < 30>>
🟠空中飘荡着一团淡蓝色的，火焰一样的存在。
<<link "发起攻击" "战斗画面">>
	<<set $lastPassage to passage()>>\
    <<set $soulClumps.hp to $soulClumps.max_hp>>
    <<set $enemyNames to ['soulClumps']>>\
<</link>>\
<</if>>

[[大墓地外围]]


:: 测试用代码 {"position":"1425,2425","size":"100,100"}
测试！
先帮你完成任务试试。

[[大墓地外围]]
<<script>>
	let G = State.variables
	addItem(G.inventory.items, G.airHumidifier, 2);
	addItem(G.inventory.items, G.silverIodidePowder, 101);
	addItem(G.inventory.items, G.soulWaitingRecycle, 101);
	addItem(G.inventory.items, G.cannonball, 11);
	addItem(G.inventory.items, G.cannon, 2);
<</script>>


:: 混乱的终幕 {"position":"1275,1650","size":"100,100"}
视野很狭窄。
具体来说，只是一条缝隙。
如果靠近的话，能看得稍微宽一点。

这该死的女人！
男人一巴掌把女人扇倒在地，纸张焚烧后留下的灰烬被扬起，四处飞散。
你那么想死是吧，那我就成全你。
又是一脚踹在她的侧腹，女人被踹翻几圈，艰难地撑起半个身子，干呕起来。

别碍事，男人猛地挣开同伴的劝阻，她就是个婊子，下贱玩意。
男人走过去，猛地抓起女人的额发，让她露出痛苦的表情，就像要展示给同伴看一样。
你看她这表情，她都不知道多享受呢……啊，我懂了，你也想玩是吧，男人露出卑劣的笑容，行啊，横竖我都得杀了她，今天就给你爽爽，好歹你也做了我那么多年的跟班，你过来。
女人痛苦地挣扎起来。

[[……->红色的闭幕]]


:: 片刻之后 {"position":"475,1150","size":"100,100"}
稍过片刻，传来了小小的当啷声，好像有什么东西掉在了地上。

在地上摸索了一下，<span class='good'>找到了一枚指环</span>。

[[返回->哥布林巢穴裂缝]]
<<silently>>\
<<script>>
	addItem(State.variables.inventory.items, State.variables.armorPiercingRing);
    State.variables.wallPenetratorTalked = true;
    State.variables.showDialog('获得物品', '获得了' + State.variables.armorPiercingRing.name + '!');
<</script>>
<</silently>>\


:: 物品掉落 {"position":"1125,375","size":"100,100"}
<<silently>>\
<<script>>
State.variables.dropLog = '';
const enemies = State.variables.enemyNames.map(name => State.variables[name]);
// DONE:请更改下列代码，当同样名字的物品存在多个的时候，直接显示其数量而不要将每一个都列出来
enemies.forEach(enemy => {
    if ('drops' in enemy) {
        // 随机计算掉落的物品
        let items = dropItems(enemy.drops);
        console.log(items);

        // 生成掉落信息文本并追加到temp中
        if (items.length > 0) {
            // 统计每种物品的数量
            let itemCounts = {};
            items.forEach(item => {
                // 假设 item 是一个对象，包含 `name` 属性
                let itemName = typeof item === 'object' && 'name' in item ? item.name : item;
                itemCounts[itemName] = (itemCounts[itemName] || 0) + 1;
            });

            // 生成掉落信息文本
            let text = Object.entries(itemCounts)
                .map(([itemName, count]) => `${itemName}×${count}`)
                .join('，'); // 用中文逗号分隔

            State.variables.dropLog += enemy.name + '掉落了<span class="good">' + text + '</span>\n'; // 添加换行符，便于区分多个敌人掉落的信息

            // 将物品添加到库存中
            addToInventory(State.variables.inventory.items, items);
        } else {
            State.variables.dropLog += enemy.name + '什么都没有掉落就离开了这个世界\n';
        }
    } else {
        State.variables.dropLog += enemy.name + '不存在可掉落的物品。';
    }
});
<</script>>
<</silently>>
$dropLog


:: 物品栏 {"position":"875,100","size":"100,100"}
<<script>>window.G = State.variables;<</script>>\
<<return "返回">>

<<for _i, _item range  $inventory.items>>\
	<<if _item.count > 0>>\
    	_item.name x _item.count <<if _item.useCallback>><<print '<<link "使用" "物品栏">><<set _temp to $globalUseCallback(' + _i + ')>><</link>>'>><</if>>
        _item.desc
        
    <</if>>\
<</for>>\

<<return "返回">>


:: 王之间 {"position":"900,900","size":"100,100"}
=<<print passage()>>=

宽敞的石室，两边挂着炽烈燃烧的火把，
和哥布林巢穴格格不入的光景。

<div class="aa">
{{{
                                           
      ::-..    :.          :.   ..-::      
   . . ..       +@@@@@@@@@%        :   :   
    -::      @@**          *%@%     .:=.   
  :.:.    #@@  %  @@@@@@@% @* +@@    . .:. 
    .    @@@@    @@@@%%@@@:   @@@+*   .    
 =      =@%   @@@@ =@@@@ +@@@:  =@%        
 @ @:  %@@  @@@  = .: .:--  +@@  *@@   @ % 
 @%@@      @@  :*#%%%%@%%*#:  =@  + : @@@@ 
       @   @  -==**%@@@%@#*#*. +@  %@      
      +@@@@. ==+%%@@@@@@@%%*==  @ @@@      
  =   :   @@ ===*+@     %#**+= =@   %   @  
 %    @   @  =*@@%@ =*+:=@%*==   =  @  @   
 #    @   @*.= -*-- ++=+ %*@*+:.@@  @  @@  
 @ =  @   @==@@@@@+ ++=+ @@@@@@ @%  @ @@@: 
 @@@@ @   @@@@@@@@= ==== @%@@@@-@@  @ :@@@ 
 % @  @  :@ #:*%#:  =--- ***% % @@  @:   : 
 :    @  %@    =-**      %:=    :@  @%     
      @   .                     @   %      
 =@+       @@@@@@@@@@@@@@@@@@@@@@      :@* 
       @@@@@@@@@@@@@@@@@@@@@@@@@@@@@       
   #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   
}}}
</div>

石室深处摆着一张石椅——看样子是直接从岩壁上凿出来的，
<<if $theGoblinKing.hp > 0>>\
上面坐着一只头戴王冠的哥布林——哥布林王。
它正是我身处此地的原因。
我要杀死它，为死去的同伴们复仇。
然后离开这个令人不快的地方。

只不过，在能够靠近它之前，还有不得不对付的敌人——三只哥布林骑士。
它们给人的感觉和外边的哥布林完全不一样。
它们已经发现了我这个闯入者，但却按兵不动。
因为哥布林王制止了它们。
<<else>>\
🟢上面有着哥布林王的尸体。
<</if>>

<<if $theRouletteEscort.hp > 0>>\
<<link "🔴攻击哥布林轮盘搀扶者" "战斗画面">>\
	<<set $theRouletteEscort.hp to $theRouletteEscort.max_hp>>\
	<<set $lastPassage to passage()>>\
    <<set $enemyNames to ['theRouletteEscort']>>\
<</link>>
<<else>>\
🟢骑士之一的哥布林轮盘搀扶者已经死亡。
<</if>>\
<<if $theArmorBreaker.hp > 0>>\
<<link "🔴攻击哥布林破甲者" "战斗画面">>\
	<<set $theArmorBreaker.hp to $theArmorBreaker.max_hp>>\
	<<set $lastPassage to passage()>>\
    <<set $enemyNames to ['theArmorBreaker']>>\
<</link>>
<<else>>\
🟢骑士之一的哥布林破甲者已经死亡。
<</if>>\
<<if $theSelfDestructor.hp > 0>>\
<<link "🔴攻击哥布林自爆者" "战斗画面">>\
	<<set $theSelfDestructor.hp to $theSelfDestructor.max_hp>>\
	<<set $lastPassage to passage()>>\
    <<set $enemyNames to ['theSelfDestructor']>>\
<</link>>
<<else>>\
🟢骑士之一的哥布林自爆者已经死亡。
<</if>>
<<if $theRouletteEscort.hp <=0 and $theArmorBreaker.hp <=0 and $theSelfDestructor.hp <=0 and $theGoblinKing.hp > 0>>
<<link "🔴攻击哥布林王" "战斗画面">>\
	<<set $theGoblinKing.hp to $theGoblinKing.max_hp>>\
	<<set $lastPassage to passage()>>\
    <<set $enemyNames to ['theGoblinKing']>>\
<</link>>
<</if>>

<<if not $goblinKingTalked and $theGoblinKing.hp > 0>>🟠[[听哥布林王说话]]<</if>>
<<if $theGoblinKing.hp <= 0>>\
🟢现在我可以从前哨站离开。
<<else>>\
🟠击败哥布林王后可以从前哨站离开。
<</if>>
返回[[巢穴深处]]


:: 王国旅行指南 {"position":"1000,375","size":"100,100"}
翻开一看，里面的书页全都被撕掉了，只剩下一张纸，上面潦草地写着：

<blockquote>
我把书全都撕了，因为你是自由的。

往王城的方向去吧，命运会指引你。

在大洪水来临之前，离开这里。
</blockquote>

[[老头的房间]]


:: 真相 {"position":"2100,2425","size":"100,100"}
勇者是背负命运之人。
只有背负命运之人，才能进入阿比斯，这是预言告诉我们的。

”阿比斯，就是我们现在站着的地方。“卡尔说。

我们一直以为打败魔王，就能拯救世界，可是——
”王国只是盯上了秽土，“，卡尔说，”利用秽土，来生产尸兵。“
这正是僵尸在帝国大量出没的原因。

”而索尔坦，就是要把这个秘密向世界宣告，让王国的可怕计划公之于众。“
”你明白你在做什么了吗？“索尔坦问。

[[我……->谣言终止者]]


:: 破土而出 {"position":"1300,2175","size":"100,100"}
黑暗，无尽的黑暗。令人窒息，同时又令人怀念的黑暗。
然后是泥土的腥味。

我在哪里？我是谁？
对了，我叫<span class="orange">$me.name</span>来着。

能动吗？
试着伸出手，感受到阻力，被什么柔软的东西挡住了，但是向上的阻力比较小，于是便向上抬手。
然后我的右手便自由了，从那上方的开口，光线便涌了进来，照的我的眼睛有些痛。
那应该是幻痛，因为我只有两对玻璃眼球——是兜帽给我的。
想起她死去的模样。
……
我的眼睛——不是幻痛，我的眼睛不知何时回来了。

我用力扒拉着泥土，努力让自己坐起身来，黑色的泥土哗啦哗啦地向身体两边落去，泥土里边混着一些虫子，不知道是蚯蚓还是蛆。

[[站起身来->大墓地外围]]


:: 祭坛 {"position":"1075,775","size":"100,100"}
<<silently>>
<<script>>
let G = State.variables;
G.rouletteCount = getItem(G.inventory.items, '命运转轮')?.count || 0;
G.dirtCount = getItem(G.inventory.items, '秽土')?.count || 0;
<</script>>
<</silently>>
=祭坛=

荒废的祭坛。
祭坛中央站着一个小丑。

“嘻嘻……嘻嘻嘻”

<div class="aa">
{{{
          ___
         /\  \
        /  \/ \
   ___  \   O /  ___
  /    \ \   / /    \
 /   __ -    -  __   \
/___/ | <>   <> | \___\
O  ___|    ^    |___  O
 /     \  -^-  /    \
/   /\  \_____/ /\   \
\_ / /          \ \_ /
O   /   /\   /\  \  O
     \ /  \ /  \ /
      O    O    O
}}}
</div>

“玩两把吗，用我准备的轮盘？”

命运转轮等级: $rouletteLevel (升级后逐渐恢复应有的性能，存在上限)
<<if $rouletteCount > 0 and $rouletteLevel < 12>>\
	* 秽土 ($dirtCount/20) <<print (($dirtCount >= 20) ? '✅' : '❌');>>
	<<if $dirtCount >= 20>>\
	<<link "🟢升级命运转轮" "祭坛">>
    	<<silently>>
    	<<script>>
        reduceItemCount(G.inventory.items, '秽土', 20);
		G.rouletteLevel += 1;
        G.showDialog('升级遗物', `命运转轮升到了等级${G.rouletteLevel}!`);
        <</script>>
        <</silently>>\
    <</link>>
	<</if>>
<</if>>

[[巢穴深处]]


:: 离开哥布林巢穴 {"position":"600,1025","size":"100,100"}
在洞窟里待久了，外边的阳光十分刺眼。
可是还有比阳光更加刺眼的东西——齐刷刷的盔甲反射阳光，令人眼花缭乱。
等待我的是整齐的军队。

<div class="aa">
{{{
&&&x;;x;x$+.+  ..       :;..;&X.;:.X
&&&+:;X+X$;;+:.:..      :+..+x&.;; $
&&&;..X+$&;+x:.x.       .+. ;x&:.;:$
&&&;. X+$&:+. .x.:.     :;. :.&x:;x&
&&&;. $+$&.x. .x.       .x:.+:X$::x$
&&&+. $x$&.X. .x.       .x..+.;&;:x&
&&&+. $x$&.X...+.       .x:.+..&$;x&
&&&x..Xx&&.$..::.        x;.+.:X&;x&
&&&+. $x&&:$. ::.        x;.+.:X&;x&
&&&;..$+&&:X. ;:.        x+.+::x&;X&
&&&+..&&&&:+. ; .X&      xxxx::+&+XX
&&&;.&&&&&+&;$X&X&$&$X$x$x&&&;:;&x$&
&&&:x&&&&&&&X&&&&&&&$&&&&&&&X:..$$X&
&&$:$&&&&&&&&&&&&&&&&&&&&&&$$:::;+X&
&&X+&&&&&&;:.::X+$&$:;;:&&&&&:::::;:
&X$.xX..&+......:;++;::..::::::::X;.
$:..::;xxx;;:.........    ...:..::.:
XX$X++;::;.....:.:.::..........::..;
$++&X&&&x::.::::.:::;::::..:...:.::.
}}}
</div>

[[继续->一个男人]]


:: 离开的方法 {"position":"1300,2550","size":"100,100"}
“你知道怎么离开这里吗？”$me.name说。
“很难。”
“大坟墓的边界被高浓度的瘴气所包围，”卢恩说，“想出去只能清除瘴气的源头。”
“瘴气的源头？”
“你应该已经见过了，”卢恩说，“那个巨大的骷髅。”

[[那卢恩是怎么进来的？]]


:: 离开这里 {"position":"600,650","size":"100,100"}
= 第二章 =

半年后……

[[继续->哥布林巢穴裂缝]]

<<script>>
let G = State.variables
window.G = G;
G.consideredInCave = false;
healing(G.me, 1.0); // 回复满hp
healing(G.me, -0.4); // 设置为60%HP
addItem(G.inventory.items, G.smallHealingPotion);
// G.me.weapon = G.bloodedIronSword;
G.me.weapon = G.default_weapon;
G.me.armor = G.bloodedDeerskinArmor;
G.wallPenetratorTalked = false; //是否遇见穿墙者
G.goblinKingTalked = false; //是否与哥布林王交谈
const geniusScientistLeft = '天才学者的悲鸣';
G[geniusScientistLeft] = {name: geniusScientistLeft, desc: '除了我想知道的东西，没有什么是重要的。'}
G.mountainGoblinSoul =  {name: '山岭哥布林的灵魂', desc: '山岭哥布林的坚韧灵魂。'};
G.normalGoblinSoul =  {name: '成年哥布林的灵魂', desc: '成年哥布林的卑微灵魂。'};
G.boneRodUseCallback = () => {
    window.G.me.weapon = G.boneRod;
	window.G.showDialog('装备武器', '成功装备了' + G.boneRod.name + '!');
}
G.boneRod = {name: '骨棒', desc: '哥布林们自己做的武器。', power: 3, useCallback: G.boneRodUseCallback};
State.variables.mountainGoblin = {
	name: '山岭哥布林', 
    exp: 150,
    max_hp: 100,
    hp: 100, 
    power: 9, 
    resistance: 6, 
    drops: [{
    	item: State.variables.mountainGoblinSoul, 
        chance: 1.0
    }]
}
State.variables.theOutpostMountainGoblin = structuredClone(State.variables.mountainGoblin);
State.variables.normalGoblin = {
	name: '成年哥布林', 
    exp: 60,
    max_hp: 40,
    hp: 40, 
    power: 5, 
    resistance: 4, 
    drops: [{
    	item: State.variables.normalGoblinSoul, 
        chance: 0.4
    }, {item: G.boneRod, chance: 0.2}]
}
G.zombieGoblin = {
	name: '僵尸哥布林', 
    exp: 120,
    max_hp: 60,
    hp: 60, 
    power: 7, 
    resistance: 3, 
	legacy: G.healer5,
    drops: [{item: G.dirt, chance: 1, count: 2}]
}
G.theWallPenetrator = {
	name: '穿墙者', 
    exp: 10,
    max_hp: 10,
    hp: 10, 
    power: 10, 
    resistance: 10, 
    drops: [{
    	item: G[geniusScientistLeft], 
        chance: 1.0
    }]
}
State.variables.armorPiercingRingDamageCalculator = function (me, enemy, fightHistory = []){
    fightHistory.push('破甲指环无视' + enemy.name + '30%防御值进行攻击!')
    let resistance = Math.floor(enemy.resistance * 0.7);
	const damage = window.calculateDamage(me.power, resistance);
    return Math.max(1, damage);
}
State.variables.armorPiercingRingUseCb = function(){
	State.variables.me.legacy = State.variables.armorPiercingRing;
    State.variables.showDialog('装备指环', '成功装备了破甲指环!');
}
State.variables.armorPiercingRing = {name: '破甲指环', desc: '指环的水晶里封存着一小片骨头。', damageCalculator : State.variables.armorPiercingRingDamageCalculator, useCallback: State.variables.armorPiercingRingUseCb}
G.rouletteLevel = 10;
G.rouletteScalar = (level) => {
    return level * 0.1;
}
G.rouletteV1DamageCalculator = function (me, enemy, fightHistory = []) {
    let G = window.G;
    fightHistory.push(`${me.name}转动了<span class="purple">命运之轮 lv${G.rouletteLevel}</span>!`);
    // 随机生成1到6之间的整数
    const dice = Math.floor(Math.random() * 6) + 1;
    let tarot = '';
    let damage = 0;
    // 根据骰子结果确定塔罗牌类型和伤害值
    if (dice >= 1 && dice <= 3) {
        tarot = '倒吊人';
        damage = 0; // 伤害为0
    } else if (dice >= 4 && dice <= 5) {
        tarot = '战车';
        damage = Math.floor(enemy.max_hp * 0.4); // 伤害为敌人生命值的40%
    } else if (dice === 6) {
        tarot = '死神';
        damage = Math.floor(enemy.max_hp * 1.2); // 伤害为敌人生命值的120%
    }
    // 将塔罗牌结果加入战斗历史
    fightHistory.push('指针停留在<span class="purple">' + tarot + '</span>!');
    let scalar = G.rouletteScalar(G.rouletteLevel); // NOTE: 根据等级改变伤害数值
    // 返回计算后的伤害值
    return Math.round(damage * scalar);
}
G.useRouletteV1 = () => {
	window.G.me.legacy = G.rouletteV1;
	window.G.showDialog('装备遗物', '成功装备了' + G.rouletteV1.name + '!');
}
G.rouletteV1 = {name: '命运转轮', desc: 'Alive or Dead?\n1~3:倒吊人，造成0点伤害\n4~5:战车，造成40%最大生命值的伤害\n6:死神，造成120%最大生命值的伤害\n可是我似乎用不了它。', damageCalculator: G.rouletteV1DamageCalculator, useCallback: G.useRouletteV1};
G.theRouletteEscort = {
	name: '哥布林轮盘搀扶者', 
    exp: 500,
    max_hp: 80,
    hp: 80, 
    power: 0, 
    resistance: 0, 
	legacy: G.rouletteV1,
    drops: [{
    	item: G.rouletteV1, 
        chance: 1.0
    }]
}
// 哥布林破甲者
G.fullDamageCalculator = function (me, enemy, fightHistory = []) {
    fightHistory.push(me.name + '的遗物<span class="purple">穿墙者无视敌方防御进行攻击</span>！');
    return me.power * 2;
}
G.fullArmorBreaker = {name: '穿墙者', desc: '无视防御。某种天赋的具象化。', damageCalculator: G.fullDamageCalculator};
G.theArmorBreaker = {
	name: '哥布林破甲者', 
    exp: 500,
    max_hp: 150,
    hp: 150, 
    power: 16, 
    resistance: 0, 
	legacy: G.fullArmorBreaker,
    drops: [{
    	item: G.fullArmorBreaker, 
        chance: 1.0
    }]
}
// 哥布林自爆者
G.theSelfDestructorCb = function (us, they, fightHistory = [], info = {}) {
    fightHistory.push(info.me.name + '自爆了!');
    for (let he of they){
		const bombPower = 200;
		const damage = bombPower - he.resistance;
		fightHistory.push(`<span class="red">${info.me.name}的自爆对${he.name}造成了${damage}点伤害!</span>`)
		he.hp = Math.max(0, he.hp-damage);
		console.log(`${he.name}的hp被重新设置为${he.hp}`)
	}
}
G.theSelfDestructorLegacy = {name: '自爆者', desc: '对每个敌人造成100点伤害。某种天赋的具象化。', deadCallback: G.theSelfDestructorCb};
G.theSelfDestructor = {
	name: '哥布林自爆者', 
    exp: 500,
    max_hp: 5,
    hp: 5, 
    power: 1, 
    resistance: 1, 
	legacy: G.theSelfDestructorLegacy,
    drops: [{
    	item: G.theSelfDestructorLegacy, 
        chance: 1.0
    }]
}
// 哥布林王
G.realGoblinKingRodName = '真*哥布林王权杖'
G.realGoblinKingRodGroupModifier = (group1, group2, fightHistory) => {
	const rodName = G.realGoblinKingRodName;
	const prototFightObj = State.variables.mountainGoblin;
	const familiarName = '【使魔】山岭哥布林';
	for(let i = 0; i< 5; i++){
		const spawned = fightObjectCopy(prototFightObj);
		spawned.name = `${familiarName}${i}号`;
		group1.push(spawned);
		console.log(rodName + '为' + group1[0].name + '的队伍召唤了' + familiarName + '!');
		fightHistory.push(rodName + '为' + group1[0].name + '的队伍召唤了' + familiarName + '!');
	}
}
G[G.realGoblinKingRodName] = {name: G.realGoblinKingRodName, desc: '在我的王之力面前颤抖吧！\n已损坏。', groupModifier: G.realGoblinKingRodGroupModifier};
G.theGoblinKing = {
	name: '哥布林王', 
    exp: 500,
    max_hp: 5,
    hp: 5, 
    power: 1, 
    resistance: 1, 
	legacy: G[G.realGoblinKingRodName],
    drops: [{
    	item: G[G.realGoblinKingRodName], 
        chance: 1.0
    }]
}

// ======================= 一些剧情变量2024.12.16 =====================
G.knifeGot = false;
G.bloodedDagger = {name: '血迹斑斑的匕首', desc: '爱用的匕首。\n已经无法使用。'};
<</script>>

<<silently>>\
<<cacheaudio "golden_season" "mp3|https://zhuobinggang.github.io/game/audio/golden_season.mp3">>
<</silently>>\


:: 称号栏 {"position":"1000,100","size":"100,100"}
<<for $i, $item range  $titles.items>>
	<<if $item.count > 0>>
    	《$item.name》<<if $item.count > 1>>x $item.count<</if>>
        $item.desc
    <</if>>
<</for>>

<<return "返回">>


:: 穿过窄门 {"position":"975,1650","size":"100,100"}
一条阴冷，漫长，狭窄的石头通道。

石墙上，间隔很远地摆放着散发出微弱亮光的火把。

仿佛没有尽头的石头通道。

[[前进->地底大空洞]]


:: 第三巡逻点 {"position":"975,1400","size":"100,100"}
=第三巡逻点=

这似乎是一个宽敞的空间。
透过两个空洞的眼窝，我觉察到这里散布着人形的黄色灵魂，以及在地上匍匐前进的黄色灵魂。
看来有一些东西是失去了视力才能够看见的。
在我旁边自称“兜帽”的人的灵魂则是白色的。

<<link "让兜帽给我治疗" "第三巡逻点">><<set $temp to $healMySelf(0.5)>><</link>>
<<link "攻击黄色灵魂" "战斗画面">>\
	<<set $prisonGuard.hp to $prisonGuard.max_hp>>\
	<<set $lastPassage to passage()>>\
    <<set $enemyNames to ['prisonGuard']>>\
<</link>>
<<link "同时攻击三个黄色灵魂" "战斗画面">>\
	<<set $prisonGuard.hp to $prisonGuard.max_hp>>\
	<<set $lastPassage to passage()>>\
    <<silently>>\
    <<script>>
        const G = State.variables;
        // spawn goblins
        G.enemyNames = []
        for (let i = 0; i < 3; i++) {
            const enemyName = 'prisonGuard_' + i;
            const prisonGuardCloned = structuredClone(G.prisonGuard);
            prisonGuardCloned.name = '监狱守卫' + i + '号';
            G[enemyName] = prisonGuardCloned;
            G.enemyNames.push(enemyName);
        }
    <</script>>
    <</silently>>\
<</link>>

在兜帽的指引下，我们可以前往关押魔物的[[地下监牢]]。

<<if $theWolfTrainer.hp > 0>>\
在空间的深处，能看到一对红色的灵魂。
“看来我们必须击败看守人才能继续前进，”兜帽说。
<<link "🔴攻击红色灵魂" "战斗画面">>\
	<<set $theWolfTrainer.hp to $theWolfTrainer.max_hp>>\
	<<set $lastPassage to passage()>>\
    <<set $enemyNames to ['theWolfTrainer', 'theWildWolf']>>\
<</link>>
<<else>>\
🟢红色灵魂已经消散。现在我们可以前往[[行刑室]]。
对现在的你来说，这种程度的敌人已经不成问题了。
可是这样的胜利又有什么意义呢？
<</if>>\


:: 第四章 {"position":"850,2150","size":"100,100"}
=第四章=

[[……->不死之王初见]]

<<silently>>
<<script>>
let G = State.variables;
//必要变量
G.talkedToRune = false;
G.gotDirtPurifier = false;
//新增的物品与敌人
G.dirtCurseCb = function (us, they, fightHistory = [], info = {}) {
	let me = info.me;
	me.hp = me.max_hp;
    fightHistory.push(`<span class="orange">秽土诅咒生效，${info.me.name}复活了！</span>`);
}
G.dirtCurse = {name: '秽土的诅咒', desc: '死亡后复活，没有限制。', deadCallback: G.dirtCurseCb};
G.handOfDead = {name: '不死之王的右手', desc: '可以使用第二个遗物。'}
G.undeadKing =  {
	name: '不死之王', 
    exp: 600,
    max_hp: 300,
    hp: 300, 
    power: 25, 
    resistance: 15, 
    // 遗物: 秽土的诅咒
    legacy: G.dirtCurse,
    drops: [{
    	item: G.handOfDead, 
        chance: 1.0
    },{
    	item: G.dirtCurse, 
        chance: 1.0
    }]
}
// 2025.1.6 新增物品
G.soulWaitingRecycle = {name: '等待回收的灵魂', desc: '你往何处去？'}
G.silverIodidePowder = {name: '碘化银粉末', desc: '黄色粉末。碘化银为碘和银的化合物，不易溶于水，但见光就分解为碘离子和银离子。银离子属于重金属离子，毒性很大，对微生物和鱼类的危害特别大。人体长期接触碘和银的化学物质也可出现中毒现象。但在自然环境中，银非常容易形成不溶于水的化合物，对环境的影响将大大减小。因此，银不太可能通过陆地或水中的食物链的积聚，达到能危害生物和动物的程度。'}
G.airHumidifier = {name: '空气加湿器', desc: '往空气中释放水汽。'}
G.cannonball = {name: '加农炮弹', desc: '海盗船必备。'}
G.cannon = {name: '高射炮', desc: '阳物崇拜。'}
// 2025.1.18 新增物品
G.ticketOfCaptainUseCb = function(){
	// BUG: 似乎在物品列表里调用这个会导致。大概原因是因为G是之前的G。打算直接呈现在游戏里算了。
	G.captain.hp = G.captain.max_hp;
    G.enemyNames = ['captain']
	G.lastPassage = getPrevPassageName()
	SugarCube.Engine.play("战斗画面")
}
G.ticketOfCaptain = {name: '亚哈船长的招待券', desc: '进入船骸的门票。使用后消失。'} // TODO: 实现使用效果
// 鲸叉
G.harpoonLevel = 1;
G.harpoonExtraChance = (level) => {
	return 30 * 0.1 * G.harpoonLevel;
}
G.harpoonDamageCal = function (me, enemy, fightHistory = []) {
	let G = window.G;
	let damage = window.calculateDamage(me.power, enemy.resistance);
    // 30% 几率造成额外 50%生命值的伤害
	let extraDamage = 0;
	let chance = Math.random() * 100;
	let extraChance = G.harpoonExtraChance(G.harpoonLevel);
	console.log(`鲸叉的触发几率为${30 + extraChance}%`);
    if (chance < (30 + extraChance)){
		extraDamage = Math.floor(enemy.hp / 3);
		fightHistory.push('<span class="purple">鲸叉</span>击中了要害，造成了额外<span class="purple">' + extraDamage + '</span>点伤害!');
	}
    // 返回计算后的伤害值
    return damage + extraDamage;
}
G.useHarpoon = () => {
	window.G.me.legacy = G.harpoon;
	window.G.showDialog('装备遗物', '成功装备了' + G.harpoon.name + '!');
}
G.harpoon = {name: '鲸叉', desc: '与强于自己百倍的怪物战斗的武器，船长存在的证明。30%几率造成50%当前生命值的伤害。升级后提升几率。', damageCalculator: G.harpoonDamageCal, useCallback: G.useHarpoon};
G.dirtPurifier = {name: '秽土净化者', desc: '卢恩出品。'}
// 2025.1.7 新增怪物
// 遗物：幽灵实体
G.ghostBeingDodgeRate = 0.5;
G.ghostBeingDamageReductor = function (enemy, me, damage, fightHistory = []) {
	let chance = G.ghostBeingDodgeRate;
    let randomChance = Math.random();
    if (randomChance <= chance) {
		fightHistory.push(me.name + '的<span class="orange">幽灵实体</span>触发并躲开了攻击!');
		damage = 0;
	}
	return damage;
}
G.ghostBeing = {name: '幽灵实体', desc: '躲避几率较高。', damageReductor: G.ghostBeingDamageReductor}; 
// END
G.silverIodideOozingOne = {name: '碘化银渗出者', desc: '外表看起来像是黄色的史莱姆。掉落碘化银粉末，概率100%。',
	exp: 200,
    max_hp: 100,
    hp: 100, 
    power: 15, 
    resistance: 15, 
    drops: [{
    	item: G.silverIodidePowder, 
        count: 5,
        chance: 0.8
    }]}
G.teruTeruBozu = {name: '晴天娃娃', desc: '一种幽灵存在。掉落空气加湿器，概率10%。', exp: 400,
    max_hp: 200,
    hp: 200, 
    power: 20, 
    resistance: 15, 
    // 遗物: 幽灵实体
    legacy: G.ghostBeing,
    drops: [{
    	item: G.airHumidifier, 
        chance: 0.1
    }]}
G.sailor = {name: '水手', desc: '游荡的水手僵尸。掉落炮弹概率50%。', exp: 400,
    max_hp: 200,
    hp: 200, 
    power: 20, 
    resistance: 20,     
	drops: [{
    	item: G.cannonball, 
        chance: 0.5,
		count: 2
    },{
    	item: G.ticketOfCaptain, 
        chance: 1,
		count: 1
    },{
    	item: G.dirt, 
        count: 10,
        chance: 0.8
    }]}
G.captain = {name: '船长', desc: '游荡的船长僵尸，唯一怪。掉落高射炮概率100%，还有某种遗物。', 
	exp: 600,
    max_hp: 600,
    hp: 600, 
    power: 25, 
    resistance: 25, 
	legacy: G.harpoon,
	drops: [{
    	item: G.cannon, 
        chance: 1,
		count: 1
    },{
    	item: G.harpoon, 
        chance: 1
    },{
    	item: G.dirt, 
        count: 16,
        chance: 1
    }]}
G.soulClumps = {name: '灵魂团块', desc: '随机刷新。掉落20个等待回收的灵魂。', exp: 400,
    max_hp: 800,
    hp: 800, 
    power: 20, 
    resistance: 20, 
    // 遗物: 幽灵实体
    legacy: G.ghostBeing,
    drops: [{
    	item: G.soulWaitingRecycle, 
        chance: 1.0,
		count: 20
    }]}
// 2025.1.20 新增卡尔剧情+怪物
G.karlTheReviver = {name: '卡尔·复生者', desc: '卡尔·复生者', exp: 1200,
    max_hp: 600,
    hp: 600, 
    power: 30, 
    resistance: 30, 
    // 遗物: 治愈者，每回合5%回复
    legacy: G.healer5,
    drops: [{
    	item: G.healer5, 
        chance: 1.0
    }]}
// 卡尔·无头骑士
G.noHeadKnightEndTurnCallback = function (us, they, fightHistory = [], info = {}) {
	const round = info.round - 1;
	const me = info.me;
	const words = ['奥义！', '闪电！', '五——', '连——', '鞭!'];
	if (round < words.length){
		fightHistory.push(`${me.name}大喊：<span class="purple">${words[round]}</span>`);
    }else{
		they.forEach(enemy => {
			enemy.hp = 0;
		})
		fightHistory.push(`<span class="red">${me.name}杀死了所有敌人。</span>`);
	}
}
G.noHeadKnightUseCallback = () => {
	window.G.me.legacy = G.noHeadKnight;
	window.G.showDialog('装备遗物', '成功装备了' + G.noHeadKnight.name + '!');
}
G.noHeadKnight = {name: '无头骑士', desc: '倒计时，必杀。', endTurnCallback: G.noHeadKnightEndTurnCallback, useCallback: G.noHeadKnightUseCallback}; 
G.karlTheHeadless = {name: '卡尔·无头骑士', desc: '卡尔·无头骑士', exp: 1200,
    max_hp: 1000,
    hp: 1000, 
    power: 10, 
    resistance: 25, 
    // 遗物: 无头骑士
    legacy: G.noHeadKnight,
    drops: [{
    	item: G.noHeadKnight, 
        chance: 1.0
    }]}
<</script>>
<<audio ":all" stop>>
<<cacheaudio "big_grave" "mp3|https://zhuobinggang.github.io/game/audio/in_big_grave.mp3">>
<</silently>>


:: 红色的闭幕 {"position":"1125,1775","size":"100,100"}
四周安静了下来。
只有液体滴落的声音。
你看向自己的右手，红色的液体正从刃尖上滴落。
你随手把匕首一扔，感到有些疲惫，便向着那边的岩石裂缝走去，打算在那温暖的石床上躺下。

温柔的黑暗笼罩了你。
手黏糊糊的让人有点不舒服，但只是一点小事而已。
就这样意识逐渐沉向深渊。

[[……->半梦半醒]]


:: 老头的任务 {"position":"425,500","size":"100,100"}
=任务：史莱姆杀手=

老头：“现在，我有一个任务交给你，去<span class='important'>杀死史莱姆，带回它们掉落的粘液</span>，向我证明你的能力。”
老头：“史莱姆经常在屋外的<span class='important'>低矮林地</span>出没。你需要先出去屋外，才能前往低矮林地。”

<<silently>>\
<<script>>
let G = State.variables;
G.slimeDropCount = getItem(G.inventory.items, '史莱姆粘液')?.count || 0;
<</script>>
<</silently>>\

* 史莱姆粘液 ($slimeDropCount/5) <<print (($slimeDropCount >= 5) ? '✅' : '❌');>>
<<if $slimeDropCount >= 5>>\
	<<link "🟢和老头换取物品" "老头的任务">>
    	<<silently>>
    	<<script>>
        reduceItemCount(G.inventory.items, '史莱姆粘液', 5);
		addItem(G.inventory.items, G.clownMask, 1);
        G.showDialog('获得物品', '获得了' + G.clownMask.name + '!');
        <</script>>
        <</silently>>\
    <</link>>
<</if>>

[[返回->向老头搭话]]


:: 老头的信 {"position":"1000,525","size":"100,100"}
你看到这封信的时候，我大概已经死了吧。
你肯定以为这老头房间里藏着不得了的东西，
结果只发现了这封信。

一定很失望吧。
如果是我的话一定会很失望。

不过你肯定会想：“这封信一定藏着关于我的身世的不得了的秘密”。

是的，我会告诉你一切真相。

[[下一页]]


:: 老头的房间 {"position":"850,375","size":"100,100"}
=老头的房间=

<<if $oldMan.hp > 0>>
老头： 站住。谁允许你随便进我的房间了？

看来<span class='red'>要想进去还得想想办法</span>。
<<else>>
煞风景的房间。
家具和我自己的起居室差不多，一张床，一张桌子而已。
桌子上摆着[[一封信->老头的信]]，和一本《[[王国旅行指南]]》。
<</if>>


[[大厅]]


:: 自杀 {"position":"850,1400","size":"100,100"}
“停停停，你想干什么？”
本该无人的牢房里，有人这样对我说了。
那人是什么时候出现的呢？
“谁在那里？”

“我？你可以叫我兜帽。跟我来，我们去夺回你失去的东西。”

[[跟上兜帽->第三巡逻点]]


:: 获取对付不死之王的道具 {"position":"1050,2800","size":"100,100"}
卢恩一个人朝着位于风暴山丘附近的研究所去了。
回来的时候，手上拿了一个雨伞一样的东西。
“我把它命名为秽土净化者，”说完，卢恩把它递给$me.name。

$me.name将秽土净化者收入囊中。

[[继续->之后的事情]]

<<silently>>\
<<script>>
	let G = State.variables
	addItem(G.inventory.items, G.dirtPurifier);
    G.gotDirtPurifier = true;
    G.showDialog('获得物品', '获得了' + G.dirtPurifier.name + '!');
	reduceItemCount(G.inventory.items, '等待回收的灵魂', 100);
	reduceItemCount(G.inventory.items, '碘化银粉末', 100);
	reduceItemCount(G.inventory.items, '空气加湿器', 1);
	reduceItemCount(G.inventory.items, '高射炮', 1);
	reduceItemCount(G.inventory.items, '加农炮弹', 10);
<</script>>
<</silently>>\


:: 行刑室 {"position":"850,1525","size":"100,100"}
=行刑室=
<<if $theEyeScooper.hp < 1 and not $plotAfterKillEyeScooperRead>><<goto '杀死剜眼者后剧情'>><</if>>\

漂浮着令人作呕的浓重血腥味的空间。

<<if $theEyeScooper.hp > 0>>\
空间中央存在着一个[[不祥的红色灵魂]]。

返回[[第三巡逻点]]
<<else>>\
🟢红色灵魂已经消散，现在我们可以[[前往窄门]]。
你能够看见东西了。
你开始觉得这个房间看起来还不赖。
<</if>>


:: 谣言终止者 {"position":"2100,2550","size":"100,100"}
就在这时——
卡尔的头被一支匕首刺穿，化为了泥土。

”害，我还以为他想说些什么呢。“
一个声音从背后传来。

[[继续->对峙卢恩]]


:: 起居室 {"position":"700,250","size":"100,100"}
=起居室=

<div class="aa">
{{{
                                    
    :----========                   
    =#++++***++**                   
    :-::::::::::::::                
    :%=:::::::::::::::.             
    .-#=:::::::::::::::::.          
      .#=:::::::::::::::::::.       
       .#+::::::::::::::::====*:.   
        .%*--=***#%%%%%%%%%%%%%%=   
        .:#%####%%%%%%%%%#+==-%%:   
         .:*##*+==--:::::::::=%*    
          .*%#--::..                
           *%#..                    
                                    
}}}
</div>

一个小小的房间，整洁，也可以说是没有什么生活气息。 
一张床，一张椅子，桌子。
桌子上面放着[[一本翻开的书]]，还有蜡烛燃尽留下的烛泪。

<<if not $beginnerWeaponGot>>\
墙上挂着一柄$beginnerWeapon['name']。\
<<link "装备" "起居室">>\
<<set $me.weapon to $beginnerWeapon>>\
<<set $beginnerWeaponGot to true>>\
<</link>>\
<<else>>\
墙上放武器的地方空空如也。\
<</if>>\

<<if not $beginnerArmorGot>>\
墙上挂着一套$beginnerArmor['name']。\
<<link "装备" "起居室">>\
<<set $me.armor to $beginnerArmor>>\
<<set $beginnerArmorGot to true>>\
<</link>>\
<<else>>\
墙上放防具的地方空空如也。\
<</if>>\


[[休息]]
到[[大厅]]去。


:: 跟上卡尔 {"position":"975,2025","size":"100,100"}
“这边有通往商店街的地下通道，”卡尔回过头说，“赶紧过来。”

正当兜帽搀扶着你站起，抬起头来的时候——卡尔的身影消失了。
一切发生得过于迅速，以至于无法理解。

沉重的击打声——如果足够冷静的话，就能分辨出，那是木头砸在盔甲上的声音。
数秒后传来了卡尔的落地声。
他被什么东西击飞了。

微弱月光照亮的，银梯周围的一小块地方。
也就是刚刚卡尔站着的地方。
“那个东西”终于现出了原型。

一个披着破烂风衣的巨大身影，以及肩上扛着的木头十字架。
<span class="red">那正是一直潜伏在黑暗之中，一开始感受到的压迫感的源头</span>。

[[继续->守墓人]]


:: 身后传来脚步声 {"position":"1300,2425","size":"100,100"}
$me.name转过头去，看见的是一副陌生面孔——
应该是这样没错，可是一身白色长袍的男人熟络地扬起手，说，”还记得我吗？“

这声音唤起了$me.name的回忆——
总记得在某个阴暗逼仄的地方听过这样的声音——

[[对了，他是……]]


:: 这不是我期盼的 {"position":"1975,2300","size":"100,100"}
”你犯了傲慢的大罪，“卡尔说。

”告诉我，你究竟为了捍卫什么而战，难道我们不能够好好谈谈吗？“$me.name说。

沉默，卡尔缓缓闭上眼睛，开口道——
”唯独和你，没有什么可以谈的。“

卡尔猛然逼近！

<<link "🔴进入战斗" "战斗画面">>\
	<<set $karlTheHeadless.hp to $karlTheHeadless.max_hp>>\
	<<set $lastPassage to "击败卡尔无头骑士">>\
    <<set $enemyNames to ['karlTheHeadless']>>\
<</link>>


:: 这样的事情 {"position":"600,1150","size":"100,100"}
“<span class='red'>你杀了梅利和索尔坦</span>。”卡尔说。

梅利和索尔坦——我当然知道他们是谁。

“你在说什么，我怎么会忍心杀死最好的朋友？”$me.name悲痛地说，“你有什么证据证明是我干的吗？”

卡尔的表情扭成一团，说，“我无法理解你，<span class="orange">你为什么会做出这样的事情？</span>……你要证据？”
一柄染血的匕首被扔出，框当一声落在$me.name的脚边。

<<if not $knifeGot>>\
<<link "拾取" "这样的事情">>
<<silently>>\
<<script>>
	addItem(G.inventory.items, G.bloodedDagger);
    G.knifeGot = true;
    G.showDialog('获得物品', '获得了' + G.bloodedDagger.name + '!');
<</script>>
<</silently>>\
<</link>>\
<</if>>\

“这不是我爱用的匕首吗？”$me.name说。

“不久前它还插在我的胸口。”卡尔说。

人群一片哗然。

[[继续->队长开口]]


:: 进入第三章 {"position":"600,1275","size":"100,100"}
=王城法庭=

大法官： 前勇者$me.name，你被指控杀害队友，对此你有什么异议吗？

法官的话音刚落，嘈杂便在群众间传播开来。
有人对我加以唾骂，有人怀疑其中隐情，当然了，也有人单纯只是想要看戏。
昨天的勇者，今天的杀人犯，这种转折怎么能够错过？

于是我说： 我没有异议。
人群瞬间炸开了锅，有人开始朝我扔东西。肃静，肃静！法官用木锤敲击桌子砰砰作响。

[[继续->杀人者]]

<<silently>>
<<script>>
let G = State.variables;
// 训狼者：lv30 几率闪避
G['hermesBootsDamageReductor'] = function (enemy, me, damage, fightHistory = []) {
	let chance = 0.3;
    let randomChance = Math.random();
    if (randomChance <= chance) {
		fightHistory.push(me.name + '的赫尔墨斯靴被动触发并躲开了攻击!');
		damage = 0;
	}
	return damage;
}
G['hermesBoots'] = {name: '赫尔墨斯靴', desc: '30%几率闪避', damageReductor: G.hermesBootsDamageReductor};
G['驯狼者的灵魂'] = {name: '驯狼者的灵魂',  desc: '驯狼者的机敏灵魂'};
G.theWolfTrainer = {
	name: '训狼者', 
    exp: 400,
    max_hp: 200,
    hp: 200, 
    power: 12, 
    resistance: 25, 
	legacy: G['hermesBoots'],
    drops: [{
    	item: State.variables['驯狼者的灵魂'], 
        chance: 1.0
    }]
}
G['荒原狼的灵魂'] = {name: '荒原狼的灵魂',  desc: '荒原狼的荒芜灵魂'};
G.theWildWolf = {
	name: '荒原狼', 
    exp: 400,
    max_hp: 200,
    hp: 200, 
    power: 20, 
    resistance: 8, 
	legacy: G.armorPiercingRing,
    drops: [{
    	item: State.variables['荒原狼的灵魂'], 
        chance: 1.0
    }]
}
G['监狱守卫的灵魂'] = {name: '监狱守卫的灵魂',  desc: '监狱守卫的苦闷灵魂'};
G.prisonGuard = {
	name: '监狱守卫', 
    exp: 200,
    max_hp: 180	,
    hp: 180, 
    power: 18, 
    resistance: 18, 
    drops: [{
    	item: State.variables['监狱守卫的灵魂'], 
        chance: 0.6
    }]
}
G['剜眼者的灵魂'] = {name: '剜眼者的灵魂',  desc: '剜眼者的残暴灵魂。从中你感受到某种共鸣——执刀医生般的严谨，以及施虐者的愉悦与狂信。'};
G.deadEyeDamageCalculator = function (me, enemy, fightHistory = []) {
    fightHistory.push(me.name + '的死眼锁定了' + enemy.name + '的要害，暴击100%！');
    let damage = Math.max(1, me.power - enemy.resistance);
    damage = damage * 2;
    return damage;
}
const useDeadEye = () => {
	window.G.me.legacy = G.deadEye;
	window.G.showDialog('装备遗物', '成功装备了' + G.deadEye.name + '!');
}
G.deadEye = {name: '剜眼者', desc: '称手的长柄勺子。比普通的勺子更深，凹陷的部分呈半球形。不具备锋利的边缘，却能给观者带来某种幻痛。会出现在眼科手术室的东西。暴击率百分之百。', damageCalculator: G.deadEyeDamageCalculator, useCallback: useDeadEye};
// TODO: 死眼作为自身的遗物可以被使用
G.theEyeScooper = {
	name: '剜眼者', 
    exp: 500,
    max_hp: 250,
    hp: 250, 
    power: 20, 
    resistance: 20, 
    // 遗物=死眼
    legacy: G.deadEye,
    drops: [{
    	item: G['剜眼者的灵魂'], 
        chance: 1.0
    },{
    	item: G.deadEye, 
        chance: 1.0
    }]
}
// 杀死剜眼者之后的剧情开关
G.plotAfterKillEyeScooperRead = false;
// ============== 2024.12.16 ================
G.glassEyeBall =  {name: '玻璃眼球', desc: '玻璃珠子，我的新眼睛。'};
// ============== 2024.12.30 ================
// 推进剧情
// TODO: 死眼作为自身的遗物可以被使用
G.bloodtheaterUseCb = function(){
	State.variables.me.weapon = G.bloodtheater;
    State.variables.showDialog('装备武器', '成功装备了喋血者!');
}
G.bloodtheater = {name: '喋血者', power: 15, desc: '索尔坦爱用的武器。', useCallback: G.bloodtheaterUseCb}
G.karl = {
	name: '武装后的卡尔', 
    exp: 500,
    max_hp: 300,
    hp: 300, 
    power:  99999, 
    resistance: 25, 
    drops: [{
    	item: G.bloodtheater, 
        chance: 1.0
    }]
}
<</script>>
<<cacheaudio "big_prison" "mp3|https://zhuobinggang.github.io/game/audio/in_big_prison.mp3">>
<</silently>>


:: 逃离不死者之王 {"position":"975,2275","size":"100,100"}
由于瘴气的包围，无法逃跑！

[[返回->不死之王初见]]

<<if $testing>>
<<link "🔴卡尔复生者" "战斗画面">>
	<<set $karlTheReviver.hp to $karlTheReviver.max_hp>>\
	<<set $lastPassage to "击败卡尔复生者">>\
    <<set $enemyNames to ['karlTheReviver']>>\
<</link>>\
<<link "🔴卡尔无头骑士" "战斗画面">>\
	<<set $karlTheHeadless.hp to $karlTheHeadless.max_hp>>\
	<<set $lastPassage to passage()>>\
    <<set $enemyNames to ['karlTheHeadless']>>\
<</link>>
<</if>>\


:: 遗物升级 {"position":"1050,2425","size":"100,100"}
<<silently>>
<<script>>
let G = State.variables;
G.rouletteCount = getItem(G.inventory.items, '命运转轮')?.count || 0;
G.dirtCount = getItem(G.inventory.items, '秽土')?.count || 0;
G.slimeRodCount = getItem(G.inventory.items, '万圣节权杖')?.count || 0;
G.harpoonCount = getItem(G.inventory.items, '鲸叉')?.count || 0;
<</script>>
<</silently>>
=遗物升级=

”毕竟我也是研究遗物的专家了，“卢恩说，”帮你升个级不是什么难事。“

万圣节权杖等级: $rodSlimeLevel (升级后增加使魔的属性，等级上限为50)
<<if $slimeRodCount > 0 and $rodSlimeLevel < 50>>\
	* 秽土 ($dirtCount/10) <<print (($dirtCount >= 10) ? '✅' : '❌');>>
	<<if $dirtCount >= 10>>\
	<<link "🟢升级万圣节权杖" "遗物升级">>\
    	<<silently>>
    	<<script>>
        reduceItemCount(G.inventory.items, '秽土', 10);
		G.rodSlimeLevel += 1;
        G.showDialog('升级遗物', `万圣节权杖升到了等级${G.rodSlimeLevel}!`);
        <</script>>
        <</silently>>\
    <</link>>
	<</if>>
<</if>>
命运转轮等级: $rouletteLevel (升级后能够突破应有的性能，最大等级为20)
<<if $rouletteCount > 0 and $rouletteLevel < 20>>\
	* 秽土 ($dirtCount/20) <<print (($dirtCount >= 20) ? '✅' : '❌');>>
	<<if $dirtCount >= 20>>\
	<<link "🟢升级命运转轮" "遗物升级">>
    	<<silently>>\
    	<<script>>
        reduceItemCount(G.inventory.items, '秽土', 20);
		G.rouletteLevel += 1;
        G.showDialog('升级遗物', `命运转轮升到了等级${G.rouletteLevel}!`);
        <</script>>
        <</silently>>\
    <</link>>
	<</if>>
<</if>>
鲸叉等级: $harpoonLevel (升级后能够提高触发被动的概率，最大等级为10)
<<if $harpoonCount > 0 and $harpoonLevel < 10>>\
	* 秽土 ($dirtCount/30) <<print (($dirtCount >= 30) ? '✅' : '❌');>>
	<<if $dirtCount >= 30>>\
	<<link "🟢升级鲸叉" "遗物升级">>
    	<<silently>>\
    	<<script>>
        reduceItemCount(G.inventory.items, '秽土', 30);
		G.harpoonLevel += 1;
        G.showDialog('升级遗物', `鲸叉升到了等级${G.harpoonLevel}!`);
        <</script>>
        <</silently>>\
    <</link>>
	<</if>>
<</if>>

[[与卢恩交谈]]


:: 遭遇卡尔和军队 {"position":"975,1775","size":"100,100"}
在那黑暗中，有什么东西的轮廓现了出来。
意识到它的时候，兜帽和你都停下了脚步。
无言的压迫感。

迎面传来脚步声。
咔嚓咔嚓，声音在巨大的空洞中回荡，显得十分单薄。

它在梯子旁，微弱的光线下现出了身形——一个身着红色披风，身披盔甲的男人。
“$me.name，你以为我们会乖乖让你逃走吗？”，男人开口了。
是卡尔。

“如果你乖乖等死，我反而会觉得无趣，这样正好。”卡尔将扛着的巨剑插入地面，像仁王一样面对着两人——
“来吧，我会用索尔坦的遗物为他复仇！”

<<link "🔴进入战斗" "战斗画面">>\
	<<set $karl.hp to $karl.max_hp>>\
	<<set $lastPassage to '和卡尔战斗之后'>>\
    <<set $enemyNames to ['karl']>>\
<</link>>


:: 那卢恩是怎么进来的？ {"position":"1425,2675","size":"100,100"}
$me.name沉思片刻，说，“你说你在这里研究很久了，那你是怎么进来的？”
卢恩说，“和哥布林巢穴的时候一样，<span class="orange">偶然卡进来的</span>。”
$me.name说，”你这个身体看起来可不像是幻影。”

“非本体——或者说副本——也有很多种存在形式，”卢恩说，“不过，拥有物质存在正是这个副本的特殊之处。这是只有在大坟墓内才有可能完成的副本形式。”
“只有在大坟墓内才有可能？这是什么意思？”

卢恩用手指了指地下，说，“大坟墓的泥土，是构成肉体的原料。我称之为<span class="orange">秽土</span>。”
”秽土……“
这番话真正的含义$me.name并不十分理解，但是比起这个，有更加急迫的问题需要问。

[[怎样击败不死者之王？]]


:: 队长开口 {"position":"725,1275","size":"100,100"}
“不要跟他废话了，”一个男人站出来说。
他的装备稍稍有些不同，看起来应该是他们的队长之类的。
“$me.name，”男人说，“如果可以的话，我真想把你就地正法，可我们毕竟是王国的正规军队…”

“我在和他说话，你能不要插嘴吗？”$me.name说。
男人愣了一下，像是要说些什么，但还是闭上了嘴巴。

"你想知道为什么？"$me.name径直朝着卡尔说。
卡尔怔怔地望着$me.name。
“因为有这样一个选项提供给我啊，点点看不是人之常情吗？”

“你疯了。”卡尔说。
“把他绑起来，带回去！”男人掷地有声地说道。

[[进入第三章]]


:: 静待片刻 {"position":"1600,2550","size":"100,100"}
但是就这样静静等待，两三分钟后，雨滴滴答答地落了下来。

雨？
比起雨来，更加轻飘飘的存在，就像是发光的雪花。
那是灵魂的碎片，不一会儿就覆盖了这一片土地。

缠绕不死之王的瘴气变弱了。

[[不死王座]]
<<silently>>\
<<script>>
	let G = State.variables;
	reduceItemCount(G.inventory.items, '秽土净化者', 1);
    G.undeadKing.legacy = null;
<</script>>
<</silently>>\


:: 风暴山丘 {"position":"1600,2175","size":"100,100"}
=风暴山丘=

不知何故常年乌云笼罩，狂风大作的山丘。
半空中漂浮着一些破布一样的东西，在狂风中呼啦作响。
狂风的呼啸之间夹杂着不知道哪里传来的孩童的嬉笑声。
仔细看的话会发现，那些东西比起破布更像是娃娃，娃娃的头部像是用墨水涂鸦一样画着夸张的笑脸，看起来有些瘆人。
<<link "发起攻击" "战斗画面">>
	<<set $lastPassage to passage()>>\
    <<set $teruTeruBozu.hp to $teruTeruBozu.max_hp>>
    <<set $enemyNames to ['teruTeruBozu']>>\
<</link>>\

<<if random(100) < 30>>
🟠空中飘荡着一团淡蓝色的，火焰一样的存在。
<<link "发起攻击" "战斗画面">>
	<<set $lastPassage to passage()>>\
    <<set $soulClumps.hp to $soulClumps.max_hp>>
    <<set $enemyNames to ['soulClumps']>>\
<</link>>\
<</if>>

[[大墓地外围]]


:: StoryScript [script]
window.fightObjectCopy = function(obj, scalar = 1){
	let resultObj = {};
	resultObj.name = obj.name;
	resultObj.hp = obj.hp * scalar;
	resultObj.max_hp = obj.max_hp * scalar;
	resultObj.resistance = obj.resistance * scalar;
	resultObj.power = obj.power * scalar;
	return resultObj;
}

function loopCall(callbackName, group1, group2, callbackFuncDict, fightHistory = []){
  	for (let i = 0; i< group1.length; i++){
    	if (callbackFuncDict['g1'][i] && callbackFuncDict['g1'][i][callbackName]) {
        	callbackFuncDict['g1'][i][callbackName](group1, group2, fightHistory);
        }
    }
  	for (let i = 0; i< group2.length; i++){
    	if (callbackFuncDict['g2'][i] && callbackFuncDict['g2'][i][callbackName]) {
        	callbackFuncDict['g2'][i][callbackName](group2, group1, fightHistory);
        }
    }
  	
}

window.calculateDamage = (attackerPower, defenderResistance) => Math.max(2 * attackerPower - defenderResistance, 1);

window.groupFight = function groupFight(group1, group2, callbackFuncDict = {'g1': {}, 'g2': {}}) {
  	window.temp2 = callbackFuncDict;

  
    const calculateDamage = window.calculateDamage;
    let fightHistory = [];
    let round = 1;
    
    // 检查所有角色的HP是否都为0
    const isGroupAlive = group => group.some(obj => obj.hp > 0);
  
  	loopCall('groupModifier', group1, group2, callbackFuncDict, fightHistory);
  	console.log('Print our members for check');
  	for (const us of group1){
    	console.log(us.name);
    }

    while (isGroupAlive(group1) && isGroupAlive(group2)) {
        fightHistory.push(`<span>回合${round}</span>`);
        fightHistory.push('<span class="beat">' + group1[0].name + '的队伍展开攻击。</span>');
        // Group1攻击Group2
        for (let i = 0; i < group1.length; i++) {
            let obj1 = group1[i]
          	if (obj1.hp <= 0) continue;  // 跳过已倒下的角色
            for (let j = 0; j < group2.length; j++) {
              	const obj2 = group2[j];
                if (obj2.hp <= 0) continue;  // 跳过已倒下的角色
              	let damage = 0;
              	if (i in callbackFuncDict['g1'] && 'damageCalculator' in callbackFuncDict['g1'][i]){
                  	console.log('G1111')
                	damage = callbackFuncDict['g1'][i]['damageCalculator'](obj1, obj2, fightHistory);
                } else {
                	damage = calculateDamage(obj1.power, obj2.resistance);
                }
				// 2024.11.19 被攻击者触发被动 G1[i] 攻击 G2[j]
				if (j in callbackFuncDict['g2'] && 'damageReductor' in callbackFuncDict['g2'][j]){
                  	console.log(obj2.name + '被攻击者触发被动');
                	damage = callbackFuncDict['g2'][j]['damageReductor'](obj1, obj2, damage, fightHistory);
                }
              	fightHistory.push(`${obj1.name}对${obj2.name}造成了<span class="red">${damage}</span>点伤害！`);
                obj2.hp = Math.max(obj2.hp - damage, 0);
				// 2024.10.27 增加自爆逻辑
              	if (obj2.hp == 0) {
                	fightHistory.push(`${obj2.name}倒下了！`);
                  	if (j in callbackFuncDict['g2'] && 'deadCallback' in callbackFuncDict['g2'][j]){
                      	console.log(`${obj2.name}的自爆逻辑！`)
                    	callbackFuncDict['g2'][j]['deadCallback'](group2, group1, fightHistory, {round, me: obj2});
                    }
                }
            }
			// 回合结束时触发回调
			if (i in callbackFuncDict['g1'] && 'endTurnCallback' in callbackFuncDict['g1'][i]){
				callbackFuncDict['g1'][i]['endTurnCallback'](group1, group2, fightHistory, {round, me: obj1});
			}
        }

        // 如果group2已经全部倒下，结束战斗
        if (!isGroupAlive(group2)) {
            fightHistory.push(group2[0].name + "的队伍全员倒下，战斗结束！");
            break;
        }

        fightHistory.push('<span class="beaten">' + group2[0].name + '的队伍展开攻击。</span>');
        // Group2攻击Group1
        for (let i = 0; i < group2.length; i++) {
          	let obj2 = group2[i]
            if (obj2.hp <= 0) continue;  // 跳过已倒下的角色
            for (let j = 0; j < group1.length; j++) {
              	const obj1 = group1[j];
                if (obj1.hp <= 0) continue;  // 跳过已倒下的角色
              	let damage = 0;
              	if (i in callbackFuncDict['g2'] && 'damageCalculator' in callbackFuncDict['g2'][i]){
                  	console.log('G222')
                	damage = callbackFuncDict['g2'][i]['damageCalculator'](obj2, obj1, fightHistory);
                } else {
                	damage = calculateDamage(obj2.power, obj1.resistance);
                }
				// 2024.11.19 被攻击者触发被动 (G2[i]攻击G1[j])
				if (j in callbackFuncDict['g1'] && 'damageReductor' in callbackFuncDict['g1'][j]){
                  	console.log(obj1.name + '被攻击者触发被动');
                	damage = callbackFuncDict['g1'][j]['damageReductor'](obj2, obj1, damage, fightHistory);
                }
              	fightHistory.push(`${obj2.name}对${obj1.name}造成了<span class="red">${damage}</span>点伤害！`);
                obj1.hp = Math.max(obj1.hp - damage, 0);
				if (obj1.hp == 0) { // 2024.10.27 增加自爆逻辑
                	fightHistory.push(`<span class="red">${obj1.name}倒下了</span>！`);
                    if (j in callbackFuncDict['g1'] && 'deadCallback' in callbackFuncDict['g1'][j]){
                      	console.log(`${obj1.name}的自爆逻辑！`)
                    	callbackFuncDict['g1'][j]['deadCallback'](group1, group2, fightHistory, {round, me: obj1});
                    }
                }
            }
			// 回合结束时触发回调
			if (i in callbackFuncDict['g2'] && 'endTurnCallback' in callbackFuncDict['g2'][i]){
				callbackFuncDict['g2'][i]['endTurnCallback'](group2, group1, fightHistory, {round, me: obj2});
			}
        }

        // 如果group1已经全部倒下，结束战斗
        if (!isGroupAlive(group1)) {
            fightHistory.push(group1[0].name + "的队伍全员倒下，战斗结束！");
            break;
        }

        round++;
    }

    return fightHistory;
}


// DONE:请更改以下代码，使掉落数量随机扰动，掉落1到drop.count个物品而非固定数量
window.dropItems = function dropItems(drops) {
    let itemList = [];
    // 遍历drops数组
    drops.forEach(drop => {
        // 生成一个随机数 (0-1)
        let randomChance = Math.random();
        // 如果随机数小于等于掉落几率，则掉落物品
        if (randomChance <= drop.chance) {
            drop.count = drop.count || 1;
            // 随机生成掉落数量 (1 到 drop.count)
            let randomDropCount = Math.floor(Math.random() * drop.count) + 1;
            // 将随机数量的物品添加到列表中
            for (let i = 0; i < randomDropCount; i++) {
                itemList.push(drop.item);
            }
        }
    });
    return itemList; // 返回掉落的物品列表
}

window.dropString = function dropString(droppedItems) {
    // 如果 droppedItems 为空，返回提示信息
    if (droppedItems.length === 0) {
        return "没有物品掉落";
    }

    // 使用一个对象来统计每种物品的数量
    let itemCountMap = {};
    droppedItems.forEach(item => {
        // 如果该物品已经在对象中，增加数量；否则，初始化为1
        if (itemCountMap[item.name]) {
            itemCountMap[item.name]++;
        } else {
            itemCountMap[item.name] = 1;
        }
    });

    // 将统计结果转换成字符串，显示掉落数量
    let itemDescriptions = Object.keys(itemCountMap).map(name => {
        let count = itemCountMap[name];
        return count > 1 ? `${count}个${name}` : `1个${name}`;
    });

    // 返回拼接后的字符串
    return itemDescriptions.join('，');
}

window.addToInventory = function(inventory, itemList) {
    itemList.forEach(item => {
        // 检查 inventory 中是否已有该物品
        let existingItem = inventory.find(inventoryItem => inventoryItem.name === item.name);
        
        if (existingItem) {
            // 如果已有该物品，增加 count
            existingItem.count++;
        } else {
            // 如果没有，新增物品并设置 count 为 1
            inventory.push({ ...item, count: 1 });
        }
    });
}

// DONE: 请更改下列函数以增加一个minimalCount的变量，默认为1，如果item.count大于等于minimalCount的时候才返回true
window.checkHavingItem = function(inventory, itemName, minimalCount = 1) {
    // 在 inventory 中查找物品
    const item = inventory.find(inventoryItem => inventoryItem.name === itemName);
    // 如果物品存在且其 count 大于或等于 minimalCount，返回 true；否则返回 false
    return item && item.count >= minimalCount;
}

window.getItem = function getItem(inventory, itemName) {
    // 查找 inventory 中的物品
    let item = inventory.find(inventoryItem => inventoryItem.name === itemName);
    
    // 如果物品存在，返回该物品，否则返回 null
    return item || null;
}

window.reduceItemCount = function reduceItemCount(inventory, itemName, count = 1) {
    // 查找 inventory 中的物品
    let item = inventory.find(inventoryItem => inventoryItem.name === itemName);
    
    if (item) {
        // 减少物品数量
        item.count -= count;
        
        // 如果物品数量小于等于 0，将 count 设为 0
        if (item.count <= 0) {
            item.count = 0;
        }
    } else {
        console.log(`物品 ${itemName} 不存在于 inventory 中。`);
    }
}

window.addItem = function addItem(inventory, item, count = 1) {
    // 查找是否已有该物品
    let existingItem = inventory.find(inventoryItem => inventoryItem.name === item.name);
    
    if (existingItem) {
        // 如果持有，更新物品的数量和描述
        existingItem.count += count;
        existingItem.desc = item.desc;  // 更新物品的描述
    } else {
        // 如果不持有，新增物品并设置 count
        inventory.push({ ...item, count: count });
    }
}

window.healing = function healing(target, percentage) {
    // 计算恢复的生命值
    const healAmount = target.max_hp * percentage;
    
    // 增加生命值，但不能超过max_hp
    target.hp = Math.min(target.hp + healAmount, target.max_hp);
    
    return target.hp; // 返回更新后的生命值
  
}

// 升级
window.levelUp = function(target){
  	target.level += 1
  	target.intrinsicPower += 1
  	target.intrinsicResistance += 1
  	target.max_hp += 10
  	console.log(target.name + ' Level Up!')
}

window.expCurve = function expCurve(level) {
    return Math.floor(5 * Math.pow(level, 2)); // 经验值需求递增曲线
}

window.expGot = function expGot(expBefore, expGot, level, levelUp) {
    let expNew = expBefore + expGot; // 计算新经验值
    let levelsGained = 0; // 用于追踪升了多少级

    // 循环检查是否可以升级
    while (expNew >= expCurve(level)) {
        expNew -= expCurve(level); // 减去当前级别的经验需求
        level += 1; // 升一级
        levelsGained += 1; // 记录升一级
        levelUp(); // 调用levelUp函数
    }

    return { newExp: expNew, newLevel: level, levelsGained: levelsGained };
}
console.log('难道说每次都要重新？')

//@deprecated 因为自动生成的法杖无法保存在游戏状态中，必须复制手写。
window.summonRodProduce = function(rodName, familiarName, prototFightObj, desc = ''){
	const useRod = () => {
		console.log('我在这里啊')
		window.G.me.ring = G[rodName];
		window.G.showDialog('装备遗物', '成功装备了' + rodName + '!');
	}
	const groupModifier = (group1, group2, fightHistory) => {
		const spawned = fightObjectCopy(prototFightObj);
		spawned.name = familiarName;
		group1.push(spawned);
		console.log(rodName + '为' + group1[0].name + '的队伍召唤了' + familiarName + '!');
		fightHistory.push(rodName + '为' + group1[0].name + '的队伍召唤了' + familiarName + '!');
	}
	const newDesc = desc || '召唤一只' + familiarName + '协同战斗。';
	window.G[rodName] = {name: rodName, desc: newDesc, groupModifier: groupModifier, useCallback: useRod};
}


window.mergeBattleLogs = function mergeBattleLogs(battleLogs) {
  const rounds = [];
  let currentRound = [];

  // 1. 分割为不同的回合部分
  for (let i = 0; i < battleLogs.length; i++) {
    const log = battleLogs[i];
    if (log.startsWith('<span>回合')) {
      // 如果有累积的回合数据，先推入 rounds
      if (currentRound.length > 0) {
        rounds.push(currentRound);
        currentRound = [];
      }
    }
    currentRound.push(log);
  }
  // 推入最后一回合
  if (currentRound.length > 0) {
    rounds.push(currentRound);
  }

  const result = [];
  let previousRoundContent = null;
  let repeatRoundIndex = null;

  // 2. 合并相同回合部分
  for (let i = 0; i < rounds.length; i++) {
    const round = rounds[i];
    //console.log(round)
    const roundContent = round.slice(1); // 去掉"回合n"的内容，仅比较回合内的具体内容

    if (previousRoundContent && JSON.stringify(roundContent) === JSON.stringify(previousRoundContent)) {
      // 如果当前回合内容和前一回合内容相同，标记为重复
      if (repeatRoundIndex === null) {
        repeatRoundIndex = i;
      }
    } else {
      // 如果内容不同，先把之前的重复合并
      if (repeatRoundIndex !== null) {
        result.push(`<span>回合……</span>`);
        repeatRoundIndex = null;
      }
      result.push(...round);  // 当前回合内容直接加入
      previousRoundContent = roundContent;
    }
  }

  // 处理最后的重复内容
  if (repeatRoundIndex !== null) {
    result.push(`回合${repeatRoundIndex + 1}……`);
  }

  return result;
}

window.getPrevPassageName = () => {
  let dd = SugarCube.State.history;
  return dd.length > 1 ? dd[dd.length - 2].title : '';
};


// 2025.1.21 中文菜单

(function () {
	/* General. */
	l10nStrings.identity = '游戏';
	l10nStrings.aborting = '终止';
	l10nStrings.cancel   = '取消';
	l10nStrings.close    = '关闭';
	l10nStrings.ok       = '确认';

	/* Errors. */
	l10nStrings.errorTitle              = '错误';
	l10nStrings.errorNonexistentPassage = '段落"{passage}"不存在';
	l10nStrings.errorSaveMissingData    = '存档缺少必须的数据，可能被读取的文件不是存档或者存档被损坏';
	l10nStrings.errorSaveIdMismatch     = '保存{identity}是错误的';

	/* Warnings. */
	l10nStrings._warningIntroLacking  = '你的浏览器可能损坏或者被禁用';
	l10nStrings._warningOutroDegraded = '，所以{identity}在受限制模式中运行。你可以继续运行，但是一些内容可能不能正确工作。';
	l10nStrings.warningNoWebStorage   = '{_warningIntroLacking} Web Storage API {_warningOutroDegraded}';
	l10nStrings.warningDegraded       = '{_warningIntroLacking} {identity}需要的功能 {_warningOutroDegraded}';

	/* Debug View. */
	l10nStrings.debugViewTitle  = '调试模式';
	l10nStrings.debugViewToggle = '切换调试模式';

	/* UI bar. */
	l10nStrings.uiBarToggle   = '打开/关闭导航栏';
	l10nStrings.uiBarBackward = '后退';
	l10nStrings.uiBarForward  = '前进';
	l10nStrings.uiBarJumpto   = '跳到{identity}的历史记录中的某一点';

	/* Jump To. */
	l10nStrings.jumptoTitle       = '跳到';
	l10nStrings.jumptoTurn        = '转到';
	l10nStrings.jumptoUnavailable = '目前没有跳跃点\u2026';

	/* Saves. */
	l10nStrings.savesTitle       = '存档';
	l10nStrings.savesDisallowed  = '在这个段落中不允许存档';
	l10nStrings.savesEmptySlot   = '\u2014 插槽空 \u2014';
	l10nStrings.savesIncapable   = '{_warningIntroLacking}支持存档所需的功能，因此本次游戏的存档功能已被禁用';
	l10nStrings.savesLabelAuto   = '自动存档';
	l10nStrings.savesLabelDelete = '删除';
	l10nStrings.savesLabelExport = '另存为\u2026';
	l10nStrings.savesLabelImport = '读取\u2026';
	l10nStrings.savesLabelLoad   = '读取';
	l10nStrings.savesLabelClear  = '全部删除';
	l10nStrings.savesLabelSave   = '保存';
	l10nStrings.savesLabelSlot   = '插槽';
	l10nStrings.savesSavedOn     = '保存在：';
	l10nStrings.savesUnavailable = '未找到存档插槽\u2026';
	l10nStrings.savesUnknownDate = '未知';

	/* Settings. */
	l10nStrings.settingsTitle = '设置';
	l10nStrings.settingsOff   = '关闭';
	l10nStrings.settingsOn    = '开启';
	l10nStrings.settingsReset = '重置为默认值';

	/* Restart. */
	l10nStrings.restartTitle  = '重新开始';
	l10nStrings.restartPrompt = '你确定要重新开始吗？未保存的进度将会丢失。';

	/* Share. */
	l10nStrings.shareTitle = '分享';

	/* Autoload. */
	l10nStrings.autoloadTitle  = '自动保存';
	l10nStrings.autoloadCancel = '前往最初的段落';
	l10nStrings.autoloadOk     = '读取自动存档';
	l10nStrings.autoloadPrompt = '有一个自动存档，读取它还是前往最初的段落？';

	/* Macros. */
	l10nStrings.macroBackText   = '返回';
	l10nStrings.macroReturnText = '返回';
  	
  	/* Adaption for sugarcube update */
  	l10nStrings.continueTitle = '继续';
  	l10nStrings.savesHeaderBrowser = '存储到浏览器';
  	l10nStrings.savesHeaderDisk = '存储到本地';
    l10nStrings.savesTextBrowserSlot = '存储槽';
    l10nStrings.textTurn = '游戏步数';
    l10nStrings.textExport = '导出';
    l10nStrings.textImport = '导入';
    l10nStrings.textClear = '清除所有存储';
    l10nStrings.textSave = '保存';
    l10nStrings.textLoad = '加载';
  	l10nStrings.restartMesgPrompt = '你确定要重新开始吗？未保存的进度将会丢失！'
  	l10nStrings.textOk = '确定';
  	l10nStrings.textCancel = '取消';
})();

:: StoryStylesheet [stylesheet]
.danger{
	color: red;
}
.good{
	color: #90EE90;
}
.important{
  	color: orange;
}
.red{
	color: red;
}
.purple{
  	color: purple;
}
.orange{
  	color: orange;
}
#history-forward{
	visibility: hidden;
}
#history-backward{
	visibility: hidden;
}
div.aa pre{
    font-family: Mona,'MS PGothic' !important; 
    line-height: 100% !important;
}