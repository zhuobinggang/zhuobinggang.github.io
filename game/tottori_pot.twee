:: StoryTitle
托托里之壶


:: StoryData
{
  "ifid": "BA16F8EA-42F7-407F-A5EC-1FF4DA8BFD8D",
  "format": "SugarCube",
  "format-version": "2.37.3",
  "start": "初始之地",
  "zoom": 1
}


:: "我会杀了你，然后把东西带走" {"position":"1025,1275","size":"100,100"}
（未完成）
[[王之间]]


:: PassageFooter {"position":"1200,100","size":"100,100"}
<<if ['初始之地', '物品栏', '称号栏'].includes(passage())>>\
	<<set $footerOn to false>>\
<<else>>\
	<<set $footerOn to true>>\
<</if>>\
<<if $footerOn and $me>>\
<hr/>\
$me.name LV$me.level <<if $titles.items.length > 0>>【<<print $titles.items.last().name>>】<</if>>
HP :<meter @value="$me.hp" min="0" @max="$me.max_hp"></meter>
[[物品栏]], [[称号栏]]
<</if>>


:: Start {"position":"1350,100","size":"100,100"}
Start
<<script>>
console.log('Start?')
<</script>>


:: StoryCaption {"position":"825,250","size":"100,100"}
$me.name LV$me.level
<<set $expNeed to $nextLevelExp()>>\
<<set _nowPassage to passage()>>\
经验值: $me.exp / $expNeed
固有攻击力: $me.intrinsicPower
固有防御力: $me.intrinsicResistance
血量: $me.hp / $me.max_hp
武器: <<link $me.weapon.name>><<set $temp to $showWeapon()>><</link>>(攻击力: $me.weapon.power)
防具: <<link $me.armor.name>><<set $temp to $showArmor()>><</link>> (防御力:  $me.armor.resistance)
<<if $me.ring>>遗物：<<link $me.ring.name>><<set _temp to $showRelics()>><</link>> <<link "卸下" _nowPassage>><<set $me.ring to null>><</link>><</if>>


:: “我明白了，我会离开，把东西给我” {"position":"900,1275","size":"100,100"}
<<silently>>
<<script>>
const usegoblinSummonRod = () => {
	State.variables.me.ring = State.variables.goblinSummonRod;
    State.variables.showDialog('装备遗物', '成功装备了' + State.variables.goblinSummonRod.name + '!');
}
const goblinSummonRodGroupModifier = (group1, group2, fightHistory) => {
    const spawnedGoblin = fightObjectCopy(State.variables.normalGoblin);
    spawnedGoblin.name = '哥布林小鬼';
    group1.push(spawnedGoblin);
    console.log('哥布林权杖为' + group1[0].name + '的队伍召唤了哥布林小鬼!')
    fightHistory.push('哥布林权杖为' + group1[0].name + '的队伍召唤了哥布林小鬼!');
}
State.variables.goblinSummonRod = {name: '哥布林王的权杖', desc: '召唤一只哥布林协同战斗。', groupModifier: goblinSummonRodGroupModifier, useCallback: usegoblinSummonRod};

window.addItem(State.variables.inventory.items, State.variables.goblinSummonRod)
State.variables.showDialog('获得物品', '获得了' + State.variables.goblinSummonRod.name + '!');
State.variables.goblinKingTalked = true;
<</script>>
<</silently>>
🟢现在我可以返回哥布林前哨站并离开。（后续剧情待完成）
[[王之间]]


:: 一本翻开的书 {"position":"525,250","size":"100,100"}
仔细一看，这不是一本书，而是自己写下的笔记。

最上面的一页写着：

明天就是我的十六岁生日了。
从明天开始，我就要离开这个家，踏上独自一人的旅程。
我没有过去的记忆。
老头也不向我透露任何东西。
也许这是一个阴谋，但是现在的我不得而知。
希望新的旅程能够给我答案……

[[返回->起居室]]


:: 下一页 {"position":"850,575","size":"100,100"}
🖕

我还想你来告诉我我的身世呢，你这个BYD不孝玩意。

[[老头的房间]]

<<script>>
State.variables.oldManLetterRead = true
<</script>>


:: 交出5个史莱姆粘液 {"position":"425,375","size":"100,100"}
<<script>>
let itemName =  '史莱姆粘液'
reduceItemCount(State.variables.inventory.items, itemName, 5)
State.variables.temp = getItem(State.variables.inventory.items, itemName)
addItem(State.variables.inventory.items, State.variables.clownMask, 1)
<</script>>
把5个史莱姆粘液给了老头，现在只剩下$temp.count个了。
不过也没什么好可惜的。

作为回报，老头给了你一个小丑面具。

[[返回->向老头搭话]]


:: 休息 {"position":"525,125","size":"100,100"}
经过剧烈的休息，体力恢复了！
<<set $me.hp to $me.max_hp>>\

[[起居室]]


:: 低矮林地 {"position":"575,525","size":"100,100"}
=低矮林地=
<<set $slime.hp to $slime.max_hp>>\

屋子旁边的小树林。
这里生活着很多弱小的魔物。
目力所及的地方就有很多史莱姆。
<<link "攻击史莱姆" "战斗画面">>\
	<<set $lastPassage to '低矮林地'>>\
    <<set $enemyNames to ['slime']>>\
<</link>>
<<link "同时攻击3只史莱姆" "战斗画面">>\
	<<set $lastPassage to '低矮林地'>>\
    <<silently>>\
    <<script>>
        const G = State.variables;
        // spawn slimes
        G.enemyNames = []
        for (let i = 0; i < 3; i++) {
            const enemyName = 'slime_' + i;
            const slimeCloned = structuredClone(G.slime);
            slimeCloned.name = '史莱姆' + i + '号';
            G[enemyName] = slimeCloned;
            G.enemyNames.push(enemyName);
        }
    <</script>>
    <</silently>>\
<</link>>

返回[[小屋前十字路口]]


:: 你能不能先从那里出来 {"position":"475,1025","size":"100,100"}
“我也想出来，可这东西不支持细微的调节。唉我现在没时间和你解释那么多，你能不能告诉我这里是哪里？”
“方位上应该是<span class='important'>底里斯王国的东南</span>。”
“哦！居然来到这种地方了吗。”
“你究竟是怎么回事？”
“一时半会给你解释不清楚，时间快到了，你有机会的话到<span class='important'>布里斯坦王国</span>来找我，就说是找<span class='important'>天才科学家卢恩</span>别人就懂了。到时候我再向你解释。”
眼看着那人的腿上出现了一些亮绿色的噪点，这过分诡异的光景让$me.name感到毛骨悚然。

"遇见能够交流的人真是不可思议。多亏底里斯和布里斯坦是邻近国家，使用同样的语言。如果是更远或者是某些古怪的地方就难说了。“
这还不算是古怪的地方吗。
”你说你在哥布林巢穴，那你应该是冒险者对吧。我待会给你<span class='important'>传送个东西过来</span>，希望能对你的冒险有帮助。希望我们有缘再见。没时间了，就"
话音戛然而止，随之消失的是男人的半身，只留下了和往常一样的岩面。

[[片刻之后]]


:: 初始之地 {"position":"700,100","size":"100,100"}
<<set $default_weapon to {name: '空手', power: 1, desc: '拳头就是最好的武器。'}>>\
<<set $default_armor to {name: '运动服', resistance: 1, desc: '居家用。'}>>\
<<set $me to {name: '你爹', hp: 100, max_hp: 100, weapon: $default_weapon, armor: $default_armor, intrinsicPower: 0, intrinsicResistance: 0, level: 1, exp: 0}>>\
我的名字叫作：
<<textbox "$me.name" "父亲">>

[[进入游戏->起居室]]


<<set $inventory to {desc: '物品栏', items: []}>>
<<set $titles to {desc: '称号', items: []}>>

<<set $beginnerWeaponGot to false>>
<<set $beginnerWeapon to {name: '木剑', power: 2, desc: '平凡的木剑。'}>>
<<set $beginnerArmor to {name: '鹿皮夹克', resistance: 2, desc: '随处可见的鹿皮夹克。'}>>
<<set $bloodedIronSword to {name: '染血的铁剑', power: 5, desc: '由于血污变钝了一些。'}>>
<<set $bloodedDeerskinArmor to {name: '染血的鹿皮夹克', resistance: 4, desc: '散发着令人恶心的腥臭。'}>>

<<set $footerOn to true>>

/* NPC & Monsters */
<<script>>
console.log('HELLO?')
State.variables.slimeDrop =  {name: '史莱姆粘液', desc: '史莱姆掉落的粘稠液体，应该不会有人需要吧？'};
State.variables.mountainGoblinSoul =  {name: '山岭哥布林的灵魂', desc: '山岭哥布林的坚韧灵魂。'};
State.variables.normalGoblinSoul =  {name: '成年哥布林的灵魂', desc: '成年哥布林的卑微灵魂。'};
State.variables.oldMan = {name: '老头', max_hp: 100, hp: 100, power: 5, resistance: 2, exp: 100};
State.variables.slime = {
	name: '史莱姆', 
    exp: 3,
    max_hp: 10,
    hp: 10, 
    power: 1, 
    resistance: 1, 
    drops: [{
    	item: State.variables.slimeDrop, 
        chance: 0.6
    }]
}
State.variables.mountainGoblin = {
	name: '山岭哥布林', 
    exp: 150,
    max_hp: 120,
    hp: 120, 
    power: 10, 
    resistance: 16, 
    drops: [{
    	item: State.variables.mountainGoblinSoul, 
        chance: 1.0
    }]
}
State.variables.theOutpostMountainGoblin = structuredClone(State.variables.mountainGoblin);
State.variables.normalGoblin = {
	name: '成年哥布林', 
    exp: 60,
    max_hp: 60,
    hp: 60, 
    power: 9, 
    resistance: 6, 
    drops: [{
    	item: State.variables.normalGoblinSoul, 
        chance: 0.4
    }]
}
State.variables.clownMask = {
	name: '小丑面具',  desc: '看起来有些诡异的面具，能够吓哭小孩。'
}
State.variables.oldManSlayer = {
	name: '俄狄浦斯',  desc: '只是杀死了个老头而已，有什么好大惊小怪的。'
}
State.variables.slimeSlayer = {
	name: '史莱姆杀手',  desc: '最好不要让动物保护协会知道。'
}
State.variables.goblinSlayer = {
	name: '护甲击破者',  desc: '第一次击败山岭哥布林。'
}
State.variables.healMySelf = function healMySelf(percentage){
	healing(State.variables.me, percentage);
}
State.variables.useSmallHealingPotion = function useSmallHealingPotion(){
	healing(State.variables.me, 0.2);
    reduceItemCount(State.variables.inventory.items, '小回复瓶');
}
State.variables.smallHealingPotion = {
	name: '小回复瓶',  desc: '回复20%HP。', useCallback: State.variables.useSmallHealingPotion
}
// 增加经验
State.variables.levelUpMe = function levelUpMe(){
	window.levelUp(State.variables.me)
}
State.variables.addExp = function  addExp(exp){
	console.log('获取了' + exp + '点经验')
	let {newExp, newLevel, levelsGained} = expGot(State.variables.me.exp, exp, State.variables.me.level, State.variables.levelUpMe);
    console.log('newExp ' + exp + '点经验')
    State.variables.me.exp = newExp;
}
State.variables.nextLevelExp = function(){
	return expCurve(State.variables.me.level);
}
State.variables.showDialog = function(title, text){
    Dialog.create(title);
    Dialog.wiki(text);
    Dialog.open();
}
State.variables.showDialogWithTextList = function(title, textList){
    Dialog.create(title);
	let text = textList.join('\n');; // 请帮我补充这一行，使用换行符来换行即可
    Dialog.wiki(text);
    Dialog.open();
}
State.variables.showWeapon = function(){
	let title = State.variables.me.weapon.name
    let desc = State.variables.me.weapon.desc
	State.variables.showDialog(title, desc)
}
State.variables.showArmor = function(){
	let title = State.variables.me.armor.name
    let desc = State.variables.me.armor.desc
	State.variables.showDialog(title, desc)
}
State.variables.showRelics = function(){
	let title = State.variables.me.ring.name
    let desc = State.variables.me.ring.desc
	State.variables.showDialog(title, desc)
}
State.variables.armorPiercingRingDamageCalculator = function (me, enemy, fightHistory = []){
    fightHistory.push('破甲指环无视' + enemy.name + '30%防御值进行攻击!')
	const damage = me.power - Math.floor(enemy.resistance * 0.7 + 1);
    return Math.max(1, damage);
}
State.variables.armorPiercingRingUseCb = function(){
	State.variables.me.ring = State.variables.armorPiercingRing;
    State.variables.showDialog('装备指环', '成功装备了破甲指环!');
}
State.variables.armorPiercingRing = {name: '破甲指环', desc: '指环的水晶里封存着一小片骨头。', damageCalculator : State.variables.armorPiercingRingDamageCalculator, useCallback: State.variables.armorPiercingRingUseCb}
// State.variables.me.ring = State.variables.armorPiercingRing;
State.variables.globalUseCallback = function(idx){
	console.log('globalUseCallback ' + idx);
    console.log('I am going to call ' + State.variables.inventory.items[idx].name + ' callback');
    State.variables.inventory.items[idx].useCallback()
}
State.variables.showDialogFightHistory = function(){
	State.variables.showDialogWithTextList('战斗记录', State.variables.fightHistory)
}
// 2024.10.25将enemyVarName废弃，改成enemies以支持组战斗
// 2024.10.25由于引用在每个新段落都会被破坏，只能通过保存名字的方式来保持联系
State.variables.enemyNames = [];
console.log('I am done')
<</script>>

<<script>>
    window.dd = State.variables
<</script>>


:: 向穿墙者搭话 {"position":"475,900","size":"100,100"}
那是十分诡异的光景，那人直直站着，上半身完全没入了岩层之中。
或者说，像是从岩石中长出来两条腿一样。

发出声音，试图吸引那个东西的注意。
“你，你好……”<span class='good'>$me.name</span>说。

“有人在那里？”那个东西用一个男人的声音回话了。
“对。”
“你能告诉我这里是什么地方吗？”
“应该是哥布林的巢穴。”
沉默了一会儿。
“哪个国家的哪个方位？”男人问道。

“[[你能不能先从那里出来]]？”


:: 向老头搭话 {"position":"550,375","size":"100,100"}
老头：今天是你的十六岁生日。从今天开始，<span class='good'>$me.name</span>，你将要开始独自的冒险生活。

老头：现在，我有一个任务交给你，去<span class='important'>杀死5只史莱姆，带回它们掉落的粘液</span>，向我证明你的能力。

老头：史莱姆经常在屋外的<span class='important'>低矮林地</span>出没。你需要先出去屋外，才能前往低矮林地。
\
<<silently>>\
<<script>>
let hasSlimeDrop = checkHavingItem(State.variables.inventory.items, '史莱姆粘液')
State.variables.hasSlimeDrop = hasSlimeDrop
if(hasSlimeDrop){
	State.variables.temp = getItem(State.variables.inventory.items, '史莱姆粘液')
}
<</script>>
<</silently>>\
\
<<if $hasSlimeDrop>>
老头： 你现在拥有$temp.count个史莱姆粘液。
	<<if $temp.count >= 5>>
    	🟢[[交出5个史莱姆粘液]]
	<</if>>
<<else>>
老头： 你还没有拿到史莱姆粘液。
<</if>>

[[返回->大厅]]


:: 听哥布林王说话 {"position":"900,1150","size":"100,100"}
哥布林王用嘶哑，走调的<span class='important'>王国公用语</span>开口说话了：

“你想要胜利的证明——我把这柄权杖给你，拿上它离开，别再回来。”
哥布林会王国公用语已经足够令人吃惊了，可是更加令我惊讶的是，它好像要放我离开。

“为什么？”
“因为你令我恐惧。”哥布林王这样说了。

身处这样的境遇，感到恐惧的是我才对吧。
“活着的东西都有弱点，不愿意放弃的东西，就是它们最大的弱点。可是你却没有这样的东西，你杀戮时的眼睛，没有任何感情的眼睛，当我用这个水晶球看见的时候就明白了。”
这个哥布林的词汇量还挺丰富的，“明白什么？”我问。
“<span class='important'>你现在还不属于这个世界</span>。”

到做选择的时候了:
[[“我明白了，我会离开，把东西给我”]]。
[["我会杀了你，然后把东西带走"]]。


:: 哥布林前哨站 {"position":"725,900","size":"100,100"}
<<set $normalGoblin.hp to $normalGoblin.max_hp>>\
=哥布林前哨站=

一个黑乎乎的洞口通往[[巢穴深处]]。

洞口外边稍微开阔一点的地方，四处站着一些无所事事的哥布林。
在黑暗的掩盖下，我们可以<<link "攻击哥布林" "战斗画面">>
	<<set $lastPassage to '哥布林前哨站'>>\
    <<set $enemyNames to ['normalGoblin']>>\
<</link>>而不会引起骚乱。
<<link "同时攻击3只哥布林" "战斗画面">>\
	<<set $lastPassage to '哥布林前哨站'>>\
    <<silently>>\
    <<script>>
        const G = State.variables;
        // spawn goblins
        G.enemyNames = []
        for (let i = 0; i < 3; i++) {
            const enemyName = 'normalGoblin_' + i;
            const goblinCloned = structuredClone(G.normalGoblin);
            goblinCloned.name = '平凡哥布林' + i + '号';
            G[enemyName] = goblinCloned;
            G.enemyNames.push(enemyName);
        }
    <</script>>
    <</silently>>\
<</link>>

地上躺着死去的同伴们的尸体。
仔细看的话能够发现，[[梅利的尸体在发光]]。

[[躲进岩石裂缝->哥布林巢穴裂缝]]


:: 哥布林巢穴裂缝 {"position":"600,775","size":"100,100"}
=狭窄的岩石裂缝=

昏暗的洞穴，空气中漂浮着腐肉和粪便的味道。

<<if not $consideredInCave>>
[[思考我现在应该做的事情]]
<<else>>
🟢前往[[哥布林前哨站]]。
<<if $meetWallPenetrater is false and random(100) < 100>>\
🟠如果我没看错的话，岩石里面长出来一个人。[[向他搭话->向穿墙者搭话]]
<</if>>\
<</if>>\


:: 大厅 {"position":"700,375","size":"100,100"}
=大厅=

老旧木头房子的客厅。
从这里可以前往[[小屋前十字路口]]，[[起居室]]和[[老头的房间]]。

如果想要休息的话，我需要先返回起居室。

<<if $oldMan.hp > 0>>
客厅中央站着一个$oldMan.name。\
<<link "攻击" "战斗画面">>
	<<set $lastPassage to '大厅'>>\
    <<script>>State.variables.enemyNames = ['oldMan'];<</script>>
<</link>>
[[向老头搭话]]
<<else>>
客厅中央躺着$oldMan.name的尸体。
🟢现在，我可以从小屋前面的十字路口离开。
<</if>>


:: 小屋前十字路口 {"position":"725,525","size":"100,100"}
=小屋前十字路口=

从这里可以看见破烂的[[小屋->大厅]]，和小屋背后的[[低矮林地]]。

大马路如此笔直，它一定可以带我去往任何地方。

<<if $oldMan.hp < 1>>
🟢是时候[[离开这里]]了。
<</if>>


:: 巢穴深处 {"position":"900,900","size":"100,100"}
=<<print passage()>>=

哥布林巢穴深处，莫名的腐臭更加严重了。

<<if $theOutpostMountainGoblin.hp > 0>>\
一只拿着火把的<span class='red'>大块头哥布林</span>在巡逻。<<link "攻击大个子哥布林" "战斗画面">>
	<<set $lastPassage to '巢穴深处'>>\
    <<set $enemyNames to ['theOutpostMountainGoblin']>>\
<</link>>\
<<else>>\
地上躺着大块头哥布林的尸体。
🟢现在我可以前往祭坛，[[王之间]]。
<</if>>

返回[[哥布林前哨站]]。


:: 思考我现在应该做的事情 {"position":"600,900","size":"100,100"}
选择永远只有两种，前进，或者是后退。

如今付出了惨重的代价，我已经失去了后退的选项。
我必须取下哥布林王的头颅，以此凭吊死去的队友们。

[[返回->哥布林巢穴裂缝]]
<<script>>
State.variables.consideredInCave = true;
<</script>>


:: 战斗画面 {"position":"1000,225","size":"100,100"}
=战斗=
<<silently>>\
<<script>>
console.log('Second check');
const enemies = State.variables.enemyNames.map(name => State.variables[name]);
const isGroupAlive = group => group.some(obj => obj.hp > 0);
State.variables.enemyNameString = ''
enemies.map(obj => State.variables.enemyNameString += obj.name + ' ')
if (!isGroupAlive(enemies)){
	console.log('Enemies All Dead!');
    State.variables.error = true;
}else{
	State.variables.error = false;
	// 处理主角的power和resistance
	const me = State.variables.me;
	me.power = me.intrinsicPower + me.weapon.power;
	me.resistance = me.intrinsicResistance + me.armor.resistance;
	const meCopy = fightObjectCopy(me);
	// 测试用代码
    console.log('打印所有敌人的名字:')
    enemies.map(obj => console.log(obj.name));
    console.log('打印我自己:')
	console.log(State.variables.me);
	// 处理敌人的objCopy
	// const enemy = State.variables[State.variables.enemyVarName];
    const enemiesCopy = enemies.map(enemy => fightObjectCopy(enemy));
	// 2024.10.21 增加指环效果
	const cb = {'g1': {}, 'g2': {}};
	if (State.variables.me.ring){
        cb['g1'][0] = {}
        if (State.variables.me.ring.damageCalculator){
            cb['g1'][0]['damageCalculator'] = State.variables.me.ring.damageCalculator;
        }
        if (State.variables.me.ring.groupModifier){
            cb['g1'][0]['groupModifier'] = State.variables.me.ring.groupModifier;
        }
	}
	// let fightHistory = fight(meCopy, enemyCopy, beforeFightCallbacks);
    let fightHistory = groupFight([meCopy], enemiesCopy, cb);
	State.variables.fightHistory = fightHistory; // 用于后续展示记录
	window.temp = fightHistory;
	// console.log(fightHistory);
	State.variables.me.hp = meCopy.hp;
    for (let i = 0; i < enemies.length; i++) {
        enemies[i].hp = enemiesCopy[i].hp;
    }
    console.log(enemies[0])
	State.variables.enemy = enemies[0];  //考虑到兼容性问题
}
<</script>>
<</silently>>\

<<if $error>>\
	$enemyNameString已经死了，请不要反复鞭尸！
<<else>>\
向$enemyNameString发起了攻击！
<<if $me.hp < 1>>\
<<goto "死亡">>\
<<else>>\
<span class='good'>$enemyNameString被你杀死了！</span>
<<include '物品掉落'>>
<<include '杀死怪物回调'>>
<<button "查看战斗记录">><<set _temp to $showDialogFightHistory()>><</button>>
<</if>>\
<</if>>\

<<link "返回" $lastPassage>><</link>>


:: 杀死怪物回调 {"position":"1250,425","size":"100,100"}
<<silently>>\
<<script>>
const G = State.variables;
G.enemyNames.map(varName => {
	G.addExp(G[varName].exp);
    if (varName.startsWith('slime')){
        console.log('杀死史莱姆')
        addItem(State.variables.titles.items, State.variables.slimeSlayer, 1)
    }else if (varName == 'oldMan'){
        console.log('杀死老头')
        if (!checkHavingItem(State.variables.titles.items, '俄狄浦斯')){
            addItem(State.variables.titles.items, State.variables.oldManSlayer)
        }
    }else if (varName == 'theOutpostMountainGoblin'){
        if (!State.variables.me.ring || State.variables.me.ring.name != '破甲指环'){
            console.log('不使用破甲戒指击破山岭哥布林');
            const title = {name: '手撕重坦者', desc: '不使用破甲戒指击破前哨站的山岭哥布林。'}
            addItem(State.variables.titles.items, title)
        }else{
            const title = {name: '封弊者', desc: '使用破甲戒指击破前哨站的山岭哥布林。'}
            addItem(State.variables.titles.items, title);
        }
        console.log('杀死前哨站的山岭哥布林');
    }
})
<</script>>
<</silently>>\


:: 梅利的尸体在发光 {"position":"725,1025","size":"100,100"}
梅利是我们队伍中的牧师。
她给自己施加了诅咒，一旦死亡就会近乎永久地为四周施加治疗光环。
如果稍微靠近就能够回复健康。

<<link "使用梅利进行治疗" "梅利的尸体在发光">><<set $temp to $healMySelf(0.05)>><</link>>
[[返回->哥布林前哨站]]


:: 死亡 {"position":"1125,250","size":"100,100"}
=死亡=

<span class='danger'>你被$enemy.name杀死了！</span>
$enemy.name的HP剩余$enemy.hp点，下次再努力吧。

<<button "查看战斗记录">><<set _temp to $showDialogFightHistory()>><</button>>

点击侧边栏的"RESTART"重新开始游戏。


:: 片刻之后 {"position":"475,1150","size":"100,100"}
稍过片刻，传来了小小的当啷声，好像有什么东西掉在了地上。
难道说是刚刚那人说的东西吗？

在地上摸索了一下，<span class='good'>找到了一枚指环</span>。

[[返回->哥布林巢穴裂缝]]
<<silently>>\
<<script>>
	addItem(State.variables.inventory.items, State.variables.armorPiercingRing);
    State.variables.meetWallPenetrater = true;
    State.variables.showDialog('获得物品', '获得了' + State.variables.armorPiercingRing.name + '!');
<</script>>
<</silently>>\


:: 物品掉落 {"position":"1125,375","size":"100,100"}
<<silently>>\
<<script>>
State.variables.dropLog = '';
const enemies = State.variables.enemyNames.map(name => State.variables[name]);
enemies.forEach(enemy => {
    if ('drops' in enemy) {
        // 随机计算掉落的物品
        let items = dropItems(enemy.drops);
        console.log(items);

        // 生成掉落信息文本并追加到temp中
        if (items.length > 0){
        	let text = dropString(items);
        	State.variables.dropLog += enemy.name + '掉落了' + text + '\n';  // 添加换行符，便于区分多个敌人掉落的信息
            addToInventory(State.variables.inventory.items, items);
        } else {
        	State.variables.dropLog += enemy.name + '什么都没有掉落就离开了这个世界\n'
        }
    } else {
    	State.variables.dropLog += enemy.name + '不存在可掉落的物品。'
    }
});
<</script>>
<</silently>>
<span class='good'>$dropLog</span>


:: 物品栏 {"position":"875,100","size":"100,100"}
<<for _i, _item range  $inventory.items>>
	<<if _item.count > 0>>
    	名称: _item.name x _item.count <<if _item.useCallback>><<print '<<link "使用" "物品栏">><<set _temp to $globalUseCallback(' + _i + ')>><</link>>'>><</if>>
        _item.desc
    <</if>>
<</for>>

<<return "返回">>


:: 王之间 {"position":"900,1025","size":"100,100"}
=<<print passage()>>=

宽敞的石室，两边挂着炽烈燃烧的火把，
和哥布林巢穴格格不入的光景。

石室深处摆着一张石椅——看样子是直接从岩壁上凿出来的，
上面坐着一只头戴王冠的哥布林。

哥布林王。
它正是我身处此地的原因。
我要杀死它，为死去的同伴们复仇。
然后离开这个令人不适的地方。

只不过，在能够靠近它之前，还有不得不对付的敌人——三只哥布林骑士。
它们有着山岭哥布林一样的巨躯，还身穿从人类士兵那里夺来的盔甲。

它们已经发现了我这个闯入者，但却按兵不动。
因为哥布林王制止了它们。

<<if not $goblinKingTalked>>🟠[[听哥布林王说话]]<</if>>
返回[[巢穴深处]]


:: 王国旅行指南 {"position":"1000,400","size":"100,100"}
翻开一看，里面的书页全都被撕掉了，只剩下一张纸，上面潦草地写着：

<blockquote>
在大洪水来临之前，离开这里
<small>PS: 我把书全都撕了，因为你是自由的</small>
</blockquote>

[[老头的房间]]


:: 王都 {"position":"450,650","size":"100,100"}
第二章……
施工中……


:: 祭坛 {"position":"1025,1025","size":"100,100"}
(游戏进度暂时只到这里)

[[巢穴深处]]


:: 离开这里 {"position":"600,650","size":"100,100"}
= 第二章 =

[[继续->哥布林巢穴裂缝]]

<<script>>
let G = State.variables
G.consideredInCave = false;
healing(G.me, 1.0); // 回复满hp
healing(G.me, -0.4); // 设置为60%HP
addItem(G.inventory.items, G.smallHealingPotion);
G.me.weapon = G.bloodedIronSword;
G.me.armor = G.bloodedDeerskinArmor;
G.meetWallPenetrater = false; //是否遇见穿墙者
G.goblinKingTalked = false; //是否与哥布林王交谈
<</script>>


:: 称号栏 {"position":"1000,100","size":"100,100"}
<<for $i, $item range  $titles.items>>
	<<if $item.count > 0>>
    	《$item.name》<<if $item.count > 1>>x $item.count<</if>>
        $item.desc
    <</if>>
<</for>>

<<return "返回">>


:: 老头的信 {"position":"1000,550","size":"100,100"}
你看到这封信的时候，我大概已经死了吧。
你肯定以为这老头房间里藏着不得了的东西，
结果只发现了这封信。

一定很失望吧。
如果是我的话一定会很失望。

不过你肯定会想：“这封信一定藏着关于我的身世的不得了的秘密”。

是的，我会告诉你一切真相。

[[下一页]]


:: 老头的房间 {"position":"850,425","size":"100,100"}
=老头的房间=

<<if $oldMan.hp > 0>>
老头： 站住。谁允许你随便进我的房间了？

看来<span class='red'>要想进去还得想想办法</span>。
<<else>>
煞风景的房间。
家具和我自己的起居室差不多，一张床，一张桌子而已。
桌子上摆着[[一封信->老头的信]]，和一本《[[王国旅行指南]]》。
<</if>>


[[大厅]]


:: 起居室 {"position":"700,250","size":"100,100"}
=起居室=

一个小小的房间，整洁，也可以说是没有什么生活气息。 
一张床，一张椅子，桌子。
桌子上面放着[[一本翻开的书]]，还有蜡烛燃尽留下的烛泪。

<<if not $beginnerWeaponGot>>\
墙上挂着一柄$beginnerWeapon['name']。\
<<link "装备" "起居室">>\
<<set $me.weapon to $beginnerWeapon>>\
<<set $beginnerWeaponGot to true>>\
<</link>>\
<<else>>\
🟢墙上放武器的地方空空如也。\
<</if>>\

<<if not $beginnerArmorGot>>\
墙上挂着一套$beginnerArmor['name']。\
<<link "装备" "起居室">>\
<<set $me.armor to $beginnerArmor>>\
<<set $beginnerArmorGot to true>>\
<</link>>\
<<else>>\
🟢墙上放防具的地方空空如也。\
<</if>>\


[[休息]]
到[[大厅]]去。


:: StoryScript [script]
window.fightObjectCopy = function(obj){
	let resultObj = {};
	resultObj.name = obj.name;
	resultObj.hp = obj.hp;
	resultObj.max_hp = obj.max_hp;
	resultObj.resistance = obj.resistance;
	resultObj.power = obj.power;
	return resultObj;
}

window.fight = function fight(obj1, obj2, beforeFightCallbacks) {
    const calculateDamage = (attackerPower, defenderResistance) => Math.max(attackerPower - defenderResistance, 1);
    console.log('FIGHT!', obj1, obj2);
    
    let fightHistory = [];
	//循环调用beforeFightCallbacks，每个callback接受obj1和obj2作为参数，最后返回一个字符串作为记录，将这个字符串存入fightHistory。
    beforeFightCallbacks.forEach(callback => {
        // Each callback is called with obj1 and obj2 as arguments
        let result = callback(obj1, obj2);
        // Push the result into the fightHistory array
        fightHistory.push(result);
    });
	
    let { hp: hp1, power: power1, resistance: res1, name: name1 } = obj1;
    let { hp: hp2, power: power2, resistance: res2, name: name2 } = obj2;

    
    let round = 1;

    while (hp1 > 0 && hp2 > 0) {
        fightHistory.push(`回合${round}`);
        let damage = calculateDamage(power1, res2);
        hp2 = Math.max(hp2 - damage, 0);
        fightHistory.push(`${name1}对${name2}造成了${damage}点伤害！`);
        if (hp2 === 0) {
            fightHistory.push(`${name2}倒下了，战斗结束！`);
            break;
        }

        damage = calculateDamage(power2, res1);
        hp1 = Math.max(hp1 - damage, 0);
        fightHistory.push(`${name2}对${name1}造成了${damage}点伤害！`);
        if (hp1 === 0) {
            fightHistory.push(`${name1}倒下了，战斗结束！`);
            break;
        }

        round++;
    }

    obj1.hp = hp1;
    obj2.hp = hp2;
    return fightHistory;
}

function loopCall(callbackName, group1, group2, callbackFuncDict, fightHistory = []){
  	for (let i = 0; i< group1.length; i++){
    	if (callbackFuncDict['g1'][i] && callbackFuncDict['g1'][i][callbackName]) {
        	callbackFuncDict['g1'][i][callbackName](group1, group2, fightHistory);
        }
    }
  	for (let i = 0; i< group2.length; i++){
    	if (callbackFuncDict['g2'][i] && callbackFuncDict['g2'][i][callbackName]) {
        	callbackFuncDict['g2'][i][callbackName](group2, group1);
        }
    }
  	
}

window.groupFight = function groupFight(group1, group2, callbackFuncDict = {'g1': {}, 'g2': {}}) {
  	window.temp2 = callbackFuncDict;

  
    const calculateDamage = (attackerPower, defenderResistance) => Math.max(attackerPower - defenderResistance, 1);
    let fightHistory = [];
    let round = 1;
    
    // 检查所有角色的HP是否都为0
    const isGroupAlive = group => group.some(obj => obj.hp > 0);
  
  	loopCall('groupModifier', group1, group2, callbackFuncDict, fightHistory);
  	console.log('Print our members for check');
  	for (const us of group1){
    	console.log(us.name);
    }

    while (isGroupAlive(group1) && isGroupAlive(group2)) {
        fightHistory.push(`<span class="important">回合${round}</span>`);
        fightHistory.push('<span class="good">' + group1[0].name + '的队伍展开攻击。</span>');
        // Group1攻击Group2
        for (let i = 0; i < group1.length; i++) {
            let obj1 = group1[i]
          	if (obj1.hp <= 0) continue;  // 跳过已倒下的角色
            for (let obj2 of group2) {
                if (obj2.hp <= 0) continue;  // 跳过已倒下的角色
              	let damage = 0;
              	if (i in callbackFuncDict['g1'] && 'damageCalculator' in callbackFuncDict['g1'][i]){
                  	console.log('G1111')
                	damage = callbackFuncDict['g1'][i]['damageCalculator'](obj1, obj2, fightHistory);
                } else {
                	damage = calculateDamage(obj1.power, obj2.resistance);
                }
                obj2.hp = Math.max(obj2.hp - damage, 0);
                fightHistory.push(`${obj1.name}对${obj2.name}造成了${damage}点伤害！`);

                if (obj2.hp === 0) {
                    fightHistory.push(`${obj2.name}倒下了！`);
                }
            }
        }

        // 如果group2已经全部倒下，结束战斗
        if (!isGroupAlive(group2)) {
            fightHistory.push(group2[0].name + "的队伍全员倒下，战斗结束！");
            break;
        }

        fightHistory.push('<span class="red">' + group2[0].name + '的队伍展开攻击。</span>');
        // Group2攻击Group1
        for (let i = 0; i < group2.length; i++) {
          	let obj2 = group2[i]
            if (obj2.hp <= 0) continue;  // 跳过已倒下的角色
            for (let obj1 of group1) {
                if (obj1.hp <= 0) continue;  // 跳过已倒下的角色
              	let damage = 0;
              	if (i in callbackFuncDict['g2'] && 'damageCalculator' in callbackFuncDict['g2'][i]){
                  	console.log('G222')
                	damage = callbackFuncDict['g2'][i]['damageCalculator'](obj1, obj2);
                } else {
                	damage = calculateDamage(obj2.power, obj1.resistance);
                }
                obj1.hp = Math.max(obj1.hp - damage, 0);
                fightHistory.push(`${obj2.name}对${obj1.name}造成了${damage}点伤害！`);

                if (obj1.hp === 0) {
                    fightHistory.push(`${obj1.name}倒下了！`);
                }
            }
        }

        // 如果group1已经全部倒下，结束战斗
        if (!isGroupAlive(group1)) {
            fightHistory.push(group1[0].name + "的队伍全员倒下，战斗结束！");
            break;
        }

        round++;
    }

    return fightHistory;
}


window.dropItems = function dropItems(drops) {
    let itemList = [];

    // 遍历drops数组
    drops.forEach(drop => {
        // 生成一个随机数 (0-1)
        let randomChance = Math.random();
      	console.log(randomChance)
      	console.log(drop.chance)
        
        // 如果随机数小于等于掉落几率，则掉落物品
        if (randomChance <= drop.chance) {
            itemList.push(drop.item);
        }
    });

    return itemList; // 返回掉落的物品列表
}

window.dropString = function dropString(droppedItems) {
    // 如果droppedItems为空，返回提示信息
    if (droppedItems.length === 0) {
        return "没有物品掉落";
    }
    
    // 提取每个物品的名字，并用逗号连接成字符串
    let itemNames = droppedItems.map(item => item.name);
    return itemNames.join(', ');
}

window.addToInventory = function(inventory, itemList) {
    itemList.forEach(item => {
        // 检查 inventory 中是否已有该物品
        let existingItem = inventory.find(inventoryItem => inventoryItem.name === item.name);
        
        if (existingItem) {
            // 如果已有该物品，增加 count
            existingItem.count++;
        } else {
            // 如果没有，新增物品并设置 count 为 1
            inventory.push({ ...item, count: 1 });
        }
    });
}

window.checkHavingItem = function(inventory, itemName) {
    // 查找 inventory 中的物品
    let item = inventory.find(inventoryItem => inventoryItem.name === itemName);
    
    // 如果物品不存在，或者 count 为 0，返回 false（不持有）
    if (!item || item.count === 0) {
        return false;
    }
    
    // 否则返回 true（持有）
    return true;
}

window.getItem = function getItem(inventory, itemName) {
    // 查找 inventory 中的物品
    let item = inventory.find(inventoryItem => inventoryItem.name === itemName);
    
    // 如果物品存在，返回该物品，否则返回 null
    return item || null;
}

window.reduceItemCount = function reduceItemCount(inventory, itemName, count) {
    // 查找 inventory 中的物品
    let item = inventory.find(inventoryItem => inventoryItem.name === itemName);
    
    if (item) {
        // 减少物品数量
        item.count -= count;
        
        // 如果物品数量小于等于 0，将 count 设为 0
        if (item.count <= 0) {
            item.count = 0;
        }
    } else {
        console.log(`物品 ${itemName} 不存在于 inventory 中。`);
    }
}

window.addItem = function addItem(inventory, item, count = 1) {
    // 查找是否已有该物品
    let existingItem = inventory.find(inventoryItem => inventoryItem.name === item.name);
    
    if (existingItem) {
        // 如果持有，更新物品的数量和描述
        existingItem.count += count;
        existingItem.desc = item.desc;  // 更新物品的描述
    } else {
        // 如果不持有，新增物品并设置 count
        inventory.push({ ...item, count: count });
    }
}

window.healing = function healing(target, percentage) {
    // 计算恢复的生命值
    const healAmount = target.max_hp * percentage;
    
    // 增加生命值，但不能超过max_hp
    target.hp = Math.min(target.hp + healAmount, target.max_hp);
    
    return target.hp; // 返回更新后的生命值
  
}

// 升级
window.levelUp = function(target){
  	target.level += 1
  	target.intrinsicPower += 1
  	target.intrinsicResistance += 1
  	target.max_hp += 10
  	console.log(target.name + ' Level Up!')
}

window.expCurve = function expCurve(level) {
    return Math.floor(5 * Math.pow(level, 2)); // 经验值需求递增曲线
}

window.expGot = function expGot(expBefore, expGot, level, levelUp) {
    let expNew = expBefore + expGot; // 计算新经验值
    let levelsGained = 0; // 用于追踪升了多少级

    // 循环检查是否可以升级
    while (expNew >= expCurve(level)) {
        expNew -= expCurve(level); // 减去当前级别的经验需求
        level += 1; // 升一级
        levelsGained += 1; // 记录升一级
        levelUp(); // 调用levelUp函数
    }

    return { newExp: expNew, newLevel: level, levelsGained: levelsGained };
}

:: StoryStylesheet [stylesheet]
.danger{
	color: red;
}
.good{
	color: #90EE90;
}
.important{
  	color: orange;
}
.red{
	color: red;
}