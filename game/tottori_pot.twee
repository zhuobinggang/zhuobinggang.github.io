:: StoryTitle
托托里之壶


:: StoryData
{
  "ifid": "BA16F8EA-42F7-407F-A5EC-1FF4DA8BFD8D",
  "format": "SugarCube",
  "format-version": "2.37.3",
  "start": "初始之地",
  "zoom": 1
}


:: "我会杀了你，然后把东西带走" {"position":"1025,1275","size":"100,100"}
哥布林王：“如果这是宿命的话……来吧，我们接受你的挑战。”

[[王之间]]


:: PassageFooter {"position":"1200,100","size":"100,100"}
<<set _nowPassage to passage()>>\
<<if ['初始之地', '物品栏', '称号栏'].includes(passage())>>\
	<<set $footerOn to false>>\
<<else>>\
	<<set $footerOn to true>>\
<</if>>\
<<if $footerOn and $me>>\
<hr/>\
$me.name LV$me.level <<if $titles.items.length > 0>>【<<print $titles.items.last().name>>】<</if>>
<<set $expNeed to $nextLevelExp()>>\
经验值: $me.exp / $expNeed
HP :<meter @value="$me.hp" min="0" @max="$me.max_hp"></meter>
[[物品栏]], [[称号栏]]
<<if $me.legacy>>遗物：<<link $me.legacy.name>><<set _temp to $showRelics()>><</link>> <<link "卸下" _nowPassage>><<set $me.legacy to null>><</link>><</if>>
<</if>>
<<script>>
	window.G = State.variables;
<</script>>


:: Start {"position":"1350,100","size":"100,100"}
Start
<<script>>
console.log('Start?')
<</script>>


:: StoryCaption {"position":"825,250","size":"100,100"}
$me.name LV$me.level
<<set $expNeed to $nextLevelExp()>>\
<<set _nowPassage to passage()>>\
经验值: $me.exp / $expNeed
固有攻击力: $me.intrinsicPower
固有防御力: $me.intrinsicResistance
血量: $me.hp / $me.max_hp
武器: <<link $me.weapon.name>><<set $temp to $showWeapon()>><</link>>(攻击力: $me.weapon.power)
防具: <<link $me.armor.name>><<set $temp to $showArmor()>><</link>> (防御力:  $me.armor.resistance)
<<if $me.legacy>>遗物：<<link $me.legacy.name>><<set _temp to $showRelics()>><</link>> <<link "卸下" _nowPassage>><<set $me.legacy to null>><</link>><</if>>


:: “我明白了，我会离开，把东西给我” {"position":"900,1275","size":"100,100"}
<<silently>>
<<script>>
addItem(State.variables.inventory.items, State.variables['哥布林王权杖'], 1);
State.variables.showDialog('获得物品', '获得了' + State.variables['哥布林王权杖'].name + '!');
State.variables.goblinKingTalked = true;
<</script>>
<</silently>>
拿到了权杖，现在我可以风风光光地收拾哥布林王了。
（需要打开物品栏进行装备）

[[王之间]]


:: 一些东西 {"position":"975,1900","size":"100,100"}
身着白色长袍的女性站在那儿，嘴唇在动。
她的表情哀伤，唤起你的同情，你想听听她在说些什么，于是你便听见了。

他是个混蛋，可是我爱他，女人说，苍白的脸颊甚至染上一丝绯红。
但是这副表情很快便消散了。
所以我会亲手杀死他，女人说。
沉默。
你的视野上下一往复，似乎是在点头。
女人笑了笑，转身离去。

这时你想起来她的名字——梅利。

[[……->关于索尔坦]]


:: 一本翻开的书 {"position":"525,250","size":"100,100"}
仔细一看，这不是一本书，而是自己写下的笔记。

最上面的一页写着：

明天就是我的十六岁生日了。
从明天开始，我就要离开这个家，踏上独自一人的旅程。
我没有过去的记忆。
老头也不向我透露任何东西。
也许这是一个阴谋，但是现在的我不得而知。
希望新的旅程能够给我答案……

[[返回->起居室]]


:: 下一页 {"position":"850,575","size":"100,100"}
🖕

我还想你来告诉我我的身世呢，你这个BYD不孝玩意。

[[老头的房间]]

<<script>>
State.variables.oldManLetterRead = true
<</script>>


:: 不祥的红色灵魂 {"position":"850,1775","size":"100,100"}
“看看谁来了，”红色的灵魂开口了，“亲爱的客人，你是需要售后服务吗？还有旁边这位戴兜帽的…哦？是吗，这就是你的选择吗？”

“你知道接下来要面对的是谁吧。”兜帽说。
我点点头。
仅仅感受到它的存在就令我的眼窝生疼——剜眼者，这就是它的名字。

“把我的眼睛还来。”
“刁难人的请求本店不予受理。”剜眼者说到，“你的眼球已经被我吃掉了。”

<<link "🔴进入战斗" "战斗画面">>\
	<<set $theEyeScooper.hp to $theEyeScooper.max_hp>>\
	<<set $lastPassage to '行刑室'>>\
    <<set $enemyNames to ['theEyeScooper']>>\
<</link>>
[[再等等->行刑室]]


:: 交出5个史莱姆粘液 {"position":"425,375","size":"100,100"}
<<script>>
let itemName =  '史莱姆粘液'
reduceItemCount(State.variables.inventory.items, itemName, 5)
State.variables.temp = getItem(State.variables.inventory.items, itemName)
addItem(State.variables.inventory.items, State.variables.clownMask, 1)
<</script>>
把5个史莱姆粘液给了老头，现在只剩下$temp.count个了。
不过也没什么好可惜的。

作为回报，老头给了你一个小丑面具。

[[返回->向老头搭话]]


:: 休息 {"position":"525,125","size":"100,100"}
经过剧烈的休息，体力恢复了！
<<set $me.hp to $me.max_hp>>\

[[起居室]]


:: 低矮林地 {"position":"575,525","size":"100,100"}
=低矮林地=
<<set $slime.hp to $slime.max_hp>>\

屋子旁边的小树林。
这里生活着很多弱小的魔物。
目力所及的地方就有很多史莱姆。
<<link "攻击史莱姆" "战斗画面">>\
	<<set $lastPassage to '低矮林地'>>\
    <<set $enemyNames to ['slime']>>\
<</link>>
<<link "同时攻击3只史莱姆" "战斗画面">>\
	<<set $lastPassage to '低矮林地'>>\
    <<silently>>\
    <<script>>
        const G = State.variables;
        // spawn slimes
        G.enemyNames = []
        for (let i = 0; i < 3; i++) {
            const enemyName = 'slime_' + i;
            const slimeCloned = structuredClone(G.slime);
            slimeCloned.name = '史莱姆' + i + '号';
            G[enemyName] = slimeCloned;
            G.enemyNames.push(enemyName);
        }
    <</script>>
    <</silently>>\
<</link>>

<<if $theClownInWoods.hp > 0 and random(100) < 100>>\
🟠树枝上吊着一个小丑。
[[向他搭话->向小丑搭话]]
<<link "攻击小丑" "战斗画面">>\
	<<set $lastPassage to '低矮林地'>>\
    <<set $enemyNames to ['theClownInWoods']>>\
<</link>>
<</if>>\

返回[[小屋前十字路口]]


:: 你能不能先从那里出来 {"position":"475,1025","size":"100,100"}
“细微的调节尚未实现，我的朋友，请告诉我这是哪里。”
“方位上是<span class='important'>底里斯王国的东南</span>。”
“居然给我干这种地方来了。”

“你是谁，是人类吗？”
“人类已经不足以定义我，我是人类以上的存在，天才学者卢恩！”
只明白了他是个怪人。

“没时间了，有机会的话到<span class='important'>布里斯坦王国</span>来，就说是找<span class='important'>天才学者卢恩</span>。到时候我再向你解释。”

眼看着那人的腿上出现了一些亮绿色的噪点。
当然了，$me.name不能够理解这幅光景的意味，只觉得毛骨悚然。

"多亏底里斯和布里斯坦是邻近国家，我们的语言才相通。如果是更远或者是某些古怪的地方就难说了。“卢恩说。
这还不算是古怪的地方吗。

”你说你在哥布林巢穴，我待会给你<span class='important'>传送个东西过来</span>，希望能对你的冒险有帮助。我们有缘再见。"
话音戛然而止，两条腿凭空消失，只留下了和往常一样的岩石。

[[片刻之后]]


:: 关于索尔坦 {"position":"975,2025","size":"100,100"}
威风凛凛的男人站在那儿。
你就是新来的家伙？连像样的装备都没有，怕是连一头哥布林都打不死吧？
男人哧笑道，毫不遮掩对你的轻蔑。
我不知道你是托了什么关系才进来的，也没兴趣知道，你记住乖乖听我指挥就行，让你送命的时候就乖乖送命，这就是你能为这个世界做出的最大贡献。

这个男人叫索尔坦，王国指定勇者。
他有一个不为人知的身份。
他秘密通敌，把重要军事情报交给敌国，意图引发战乱。

[[……->混乱的终幕]]


:: 击败卡尔剧情 {"position":"525,2425","size":"100,100"}
卡尔手中的巨剑，喋血者，有一个不为人知的特性。
它对杀死前持有者的人有着异样的执着。
无论任何情况，只要被划到，一击致命。

你已经死了，出现在这里只是一种假象。

[[回到真实世界->和卡尔战斗之后]]

<<script>>
let G = State.variables;
G.karl.hp = G.karl.max_hp;
<</script>>


:: 初始之地 {"position":"700,100","size":"100,100"}
<<set $default_weapon to {name: '空手', power: 1, desc: '拳头就是最好的武器。'}>>\
<<set $default_armor to {name: '运动服', resistance: 1, desc: '居家用。'}>>\
<<set $me to {name: '你爹', hp: 100, max_hp: 100, weapon: $default_weapon, armor: $default_armor, intrinsicPower: 0, intrinsicResistance: 0, level: 1, exp: 0}>>\
我的名字叫作：
<<textbox "$me.name" "父亲">>

[[进入游戏->起居室]]


<<set $inventory to {desc: '物品栏', items: []}>>
<<set $titles to {desc: '称号', items: []}>>

<<set $beginnerWeaponGot to false>>
<<set $beginnerWeapon to {name: '木剑', power: 2, desc: '平凡的木剑。'}>>
<<set $beginnerArmor to {name: '鹿皮夹克', resistance: 2, desc: '随处可见的鹿皮夹克。'}>>
<<set $bloodedIronSword to {name: '染血的铁剑', power: 5, desc: '由于血污变钝了一些。'}>>
<<set $bloodedDeerskinArmor to {name: '染血的鹿皮夹克', resistance: 4, desc: '散发着令人恶心的腥臭。'}>>

<<set $footerOn to true>>

/* NPC & Monsters */
<<script>>
window.G = State.variables;
console.log('HELLO?')
State.variables.slimeDrop =  {name: '史莱姆粘液', desc: '史莱姆掉落的粘稠液体，应该不会有人需要吧？'};
State.variables.mountainGoblinSoul =  {name: '山岭哥布林的灵魂', desc: '山岭哥布林的坚韧灵魂。'};
State.variables.normalGoblinSoul =  {name: '成年哥布林的灵魂', desc: '成年哥布林的卑微灵魂。'};
State.variables.slimeSoul =  {name: '史莱姆的灵魂', desc: '史莱姆的天真灵魂。'};
State.variables.oldMan = {name: '老头', max_hp: 100, hp: 100, power: 5, resistance: 2, exp: 100};
State.variables.slime = {
	name: '史莱姆', 
    exp: 3,
    max_hp: 10,
    hp: 10, 
    power: 1, 
    resistance: 1, 
    drops: [{item: State.variables.slimeDrop, chance: 0.6}, {item: State.variables.slimeSoul, chance: 0.8, count: 2}, ]
}
State.variables.mountainGoblin = {
	name: '山岭哥布林', 
    exp: 150,
    max_hp: 120,
    hp: 120, 
    power: 10, 
    resistance: 16, 
    drops: [{
    	item: State.variables.mountainGoblinSoul, 
        chance: 1.0
    }]
}
State.variables.theOutpostMountainGoblin = structuredClone(State.variables.mountainGoblin);
State.variables.normalGoblin = {
	name: '成年哥布林', 
    exp: 60,
    max_hp: 60,
    hp: 60, 
    power: 9, 
    resistance: 6, 
    drops: [{
    	item: State.variables.normalGoblinSoul, 
        chance: 0.4
    }]
}
State.variables.clownMask = {
	name: '小丑面具',  desc: '看起来有些诡异的面具，能够吓哭小孩。'
}
State.variables.oldManSlayer = {
	name: '俄狄浦斯',  desc: '只是杀死了个老头而已，有什么好大惊小怪的。'
}
State.variables.slimeSlayer = {
	name: '史莱姆杀手',  desc: '最好不要让动物保护协会知道。'
}
State.variables.goblinSlayer = {
	name: '护甲击破者',  desc: '第一次击败山岭哥布林。'
}
State.variables.healMySelf = function healMySelf(percentage){
	healing(State.variables.me, percentage);
}
State.variables.useSmallHealingPotion = function useSmallHealingPotion(){
	healing(State.variables.me, 0.2);
    reduceItemCount(State.variables.inventory.items, '小回复瓶');
}
State.variables.smallHealingPotion = {
	name: '小回复瓶',  desc: '回复20%HP。', useCallback: State.variables.useSmallHealingPotion
}
// 增加经验
State.variables.levelUpMe = function levelUpMe(){
	window.levelUp(State.variables.me)
}
State.variables.addExp = function  addExp(exp){
	console.log('获取了' + exp + '点经验')
	let {newExp, newLevel, levelsGained} = expGot(State.variables.me.exp, exp, State.variables.me.level, State.variables.levelUpMe);
    console.log('newExp ' + exp + '点经验')
    State.variables.me.exp = newExp;
}
State.variables.nextLevelExp = function(){
	return expCurve(State.variables.me.level);
}
State.variables.showDialog = function(title, text){
    Dialog.create(title);
    Dialog.wiki(text);
    Dialog.open();
}
State.variables.showDialogWithTextList = function(title, textList){
    Dialog.create(title);
	let text = textList.join('\n');; // 请帮我补充这一行，使用换行符来换行即可
    Dialog.wiki(text);
    Dialog.open();
}
State.variables.showWeapon = function(){
	let title = State.variables.me.weapon.name
    let desc = State.variables.me.weapon.desc
	State.variables.showDialog(title, desc)
}
State.variables.showArmor = function(){
	let title = State.variables.me.armor.name
    let desc = State.variables.me.armor.desc
	State.variables.showDialog(title, desc)
}
State.variables.showRelics = function(){
	let title = State.variables.me.legacy.name
    let desc = State.variables.me.legacy.desc
	State.variables.showDialog(title, desc)
}
State.variables.armorPiercingRingDamageCalculator = function (me, enemy, fightHistory = []){
    fightHistory.push('破甲指环无视' + enemy.name + '30%防御值进行攻击!')
	const damage = me.power - Math.floor(enemy.resistance * 0.7 + 1);
    return Math.max(1, damage);
}
State.variables.armorPiercingRingUseCb = function(){
	State.variables.me.legacy = State.variables.armorPiercingRing;
    State.variables.showDialog('装备指环', '成功装备了破甲指环!');
}
State.variables.armorPiercingRing = {name: '破甲指环', desc: '指环的水晶里封存着一小片骨头。', damageCalculator : State.variables.armorPiercingRingDamageCalculator, useCallback: State.variables.armorPiercingRingUseCb}
State.variables.globalUseCallback = function(idx){
	console.log('globalUseCallback ' + idx);
    console.log('I am going to call ' + State.variables.inventory.items[idx].name + ' callback');
    State.variables.inventory.items[idx].useCallback()
}
State.variables.showDialogFightHistory = function(){
	State.variables.showDialogWithTextList('战斗记录', State.variables.fightHistory)
}
// 2024.10.25将enemyVarName废弃，改成enemies以支持组战斗
// 2024.10.25由于引用在每个新段落都会被破坏，只能通过保存名字的方式来保持联系
State.variables.enemyNames = [];
console.log('I am done')
const useRodSlime = () => {
	const rodName = '万圣节权杖';
	window.G.me.legacy = G[rodName];
	window.G.showDialog('装备遗物', '成功装备了' + rodName + '!');
}
const rodSlimeGroupModifier = (group1, group2, fightHistory) => {
	const rodName = '万圣节权杖';
	const prototFightObj = State.variables.slime;
	const familiarName = '【使魔】史莱姆';
	const spawned = fightObjectCopy(prototFightObj);
	spawned.name = familiarName;
	group1.push(spawned);
	console.log(rodName + '为' + group1[0].name + '的队伍召唤了' + familiarName + '!');
	fightHistory.push(rodName + '为' + group1[0].name + '的队伍召唤了' + familiarName + '!');
}
window.G['万圣节权杖'] = {name: '万圣节权杖', desc: '万圣节特典。召唤一只【使魔】史莱姆协同战斗！', groupModifier: rodSlimeGroupModifier, useCallback: useRodSlime};
const useRodGoblin = () => {
	const rodName = '哥布林王权杖';
	window.G.me.legacy = G[rodName];
	window.G.showDialog('装备遗物', '成功装备了' + rodName + '!');
}
State.variables.theClownInWoods = {
	name: '林中小丑', 
    exp: 200,
    max_hp: 200,
    hp: 200, 
    power: 20, 
    resistance: 20, 
    drops: [{
    	item: State.variables['万圣节权杖'], 
        chance: 1.0
    }]
}
const rodGoblinGroupModifier = (group1, group2, fightHistory) => {
	const rodName = '哥布林王权杖';
	const prototFightObj = State.variables.normalGoblin;
	const familiarName = '【使魔】哥布林';
	const spawned = fightObjectCopy(prototFightObj);
	spawned.name = familiarName;
	group1.push(spawned);
	console.log(rodName + '为' + group1[0].name + '的队伍召唤了' + familiarName + '!');
	fightHistory.push(rodName + '为' + group1[0].name + '的队伍召唤了' + familiarName + '!');
}
window.G['哥布林王权杖'] = {name: '哥布林王权杖', desc: '召唤一只【使魔】哥布林协同战斗。', groupModifier: rodGoblinGroupModifier, useCallback: useRodGoblin};
<</script>>
<<script>>
    window.dd = State.variables
<</script>>


:: 前往窄门 {"position":"725,1900","size":"100,100"}
行刑室一角，一扇木门微微敞开。

“看来你已经可以看见东西了，”兜帽说。
你点点头。
兜帽身上披着的宽大风衣显得他个头很小，脸隐藏在帽沿的阴影之下。

“那就好，离开这里吧。那是一条通往行刑广场的密道，我们可以从那里逃走。”
……
兜帽注意到你的视线，沉默。
“你要在这里将我杀死？”说着这样的话，他的声音中却听不见一丝恐惧。

如果是“我”的话，会怎么做？
……

“你犹豫了，是你输了。”兜帽说。“走吧，让我们离开这里。”

[[穿过窄门]]


:: 前进 {"position":"725,2150","size":"100,100"}
=地底大空洞=

石头通道的尽头，空旷，黑暗的空间。
待眼睛适应那黑暗，
便发现在那无限绵密的黑暗之中，一线银色光芒从顶端洒落，
在那微弱的光芒之中，是一条长长的木梯。
木梯无依无靠，径直从那顶端插入地面，
在这过分宽广的空间中，就像是蜘蛛之丝一样脆弱。

“走吧，”兜帽说，“爬上那条木梯，就是行刑广场了。”

“之后我们去哪里？”

“是呢，”兜帽说，“<span class="orange">去一个更加真实的地方怎么样</span>？”说完便迈出脚步。

[[跟上->遭遇卡尔和军队]]


:: 半梦半醒 {"position":"975,2400","size":"100,100"}
你当然知道这是什么，毕竟又不是失忆。
不过，也只是一些无足挂齿的小事罢了，这也是事实。 
<span class="orange">莫名其妙被选中</span>，加入勇者的小队，半年，试着接受他们的规矩，跟他们一起行动，然后看到这些无聊的东西，让人连回忆都懒得回忆。

事到如今怎么会看见这些场景呢？
可能是眼球失而复得的幻觉所致。
理所当然，毕竟眼睛离大脑那么近，看见什么都不奇怪。
新的眼睛只是两个廉价的玻璃珠子，看见这些无聊的场景也是理所当然。
可能有人爱看这些也说不定，那就让他们看去吧。
而我是时候该睁开眼睛了。

<<set $plotAfterKillEyeScooperRead to true>>

[[睁开眼睛->行刑室]]


:: 向小丑搭话 {"position":"450,775","size":"100,100"}
嘻嘻……嘻嘻嘻

<div class="aa">
{{{
&&&&&&&&&&&$&&&&&$XX$&&&&&&&&&&&&&&$&$
&&&&&&&&&&&&&&&&&$xX$&&&&$X&&&&&&&&&&&
&&&&&&&&&&&&&&&&$&&&&&&&&&$&&&&&&&&$&&
&&&&&&&&&&&&&&&$x;::;+X&&&$&&&&&&&&&&&
&&&&&&&&&&&&&$++X$$$Xx+;x&&&&&&&&&&&&&
&&&&&&&&&&&&$+X;.:...:+x+x&&&&&&&&&&&&
&&&&&&&&&&&&XXxxXX;.xXXXxx&&&&&&&&&&&&
&&&&&&&&&&&&$X$&Xx+:$x&&$++&&&&&&&&&&&
&&&&&&&&&&&&+;:;xx$$$xx;;;:x&&&&&&&&&&
&&&&&&&&&&&&;.;+;;&&&;xX+;::X&&&&&&&&&
&&&&&&&&&&$:..;x+x+xXx;++;;:.;$&&&&&&&
&&&&&&&&&+......::;;+;;;;;;:::;$&&&&&&
&&&&&&&$.........:xX+;;;;;;;;;:;$&&&&&
&&&&&&X......:.....:::+xxx+;;::.;&&&&&
&&&&&X.......   .:.::;++x+++;;:::x&&&&
&&&&+.::.........:;::::;++++;;;;;:$&&&
&&&;.................::::;;;;;;;;;;$&&
&&;.........:........::::::;;;;;;;;x&&
&;.........:...:.....:::::;;;;;;;;;;&&
X.........:;.........:;:::;++;;;;;;;x&
........::;;....:....:;:::;+++;;;;;;;&
.......::;+:...::....;;:::;;+++++;;;:X
......::;+;:...::....;;;:::;++++++;;;:
}}}
</div>

有人寻找灵魂，有人找寻面具，
如果你能带给我3个面具，也许我会给你一份礼物。

<<silently>>\
<<script>>
State.variables.temp1 = checkHavingItem(State.variables.inventory.items, '小丑面具')
if(State.variables.temp1){
	State.variables.temp2 = getItem(State.variables.inventory.items, '小丑面具')
}
<</script>>
<</silently>>\
\
<<if $temp1>>\
小丑：你现在拥有$temp2.count个小丑面具。
<<if $temp2.count >= 3>>\
	<<link "使用3个小丑面具换取万圣节礼物" "向小丑搭话">>
    	<<silently>>
    	<<script>>
        const itemName =  '小丑面具';
		reduceItemCount(State.variables.inventory.items, itemName, 3);
		addItem(State.variables.inventory.items, State.variables['万圣节权杖'], 1);
        State.variables.showDialog('获得物品', '获得了' + State.variables['万圣节权杖'].name + '!');
        <</script>>
        <</silently>>\
    <</link>>
<</if>>
<</if>>

[[低矮林地]]


:: 向穿墙者搭话 {"position":"475,900","size":"100,100"}
该说那是一个人吗，事实上只是两条腿而已。
不过可以想象这样的情形：一个人直挺挺站着，上半身完全没入岩石之中。

发出声音，试图吸引那个东西的注意。

“有人在那里？”那个东西问道，一个男人的声音。
是我能够理解的语言。
于是我给了它肯定的答复。

“这是什么地方？”
哥布林巢穴，我说。

沉默。
“哪个国家的哪个方位？”那东西继续问。

“[[你能不能先从那里出来]]？”


:: 向老头搭话 {"position":"550,375","size":"100,100"}
老头：今天是你的十六岁生日。从今天开始，<span class='good'>$me.name</span>，你将要开始独自的冒险生活。

老头：现在，我有一个任务交给你，去<span class='important'>杀死5只史莱姆，带回它们掉落的粘液</span>，向我证明你的能力。

老头：史莱姆经常在屋外的<span class='important'>低矮林地</span>出没。你需要先出去屋外，才能前往低矮林地。
\
<<silently>>\
<<script>>
let hasSlimeDrop = checkHavingItem(State.variables.inventory.items, '史莱姆粘液')
State.variables.hasSlimeDrop = hasSlimeDrop
if(hasSlimeDrop){
	State.variables.temp = getItem(State.variables.inventory.items, '史莱姆粘液')
}
<</script>>
<</silently>>\
\
<<if $hasSlimeDrop>>
老头： 你现在拥有$temp.count个史莱姆粘液。
	<<if $temp.count >= 5>>
    	🟢[[交出5个史莱姆粘液]]
	<</if>>
<<else>>
老头： 你还没有拿到史莱姆粘液。
<</if>>

[[返回->大厅]]


:: 听哥布林王说话 {"position":"900,1150","size":"100,100"}
哥布林王用嘶哑，走调的<span class='important'>王国公用语</span>开口说话了：

“你想要胜利的证明——我把这柄权杖给你，拿上它离开，别再回来。”
哥布林会王国公用语已经足够令人吃惊了，可是更加令我惊讶的是，它好像要放我离开。

“为什么？”
“你知道为什么，”哥布林王说，“却假装不知道。”
这句话让我感到莫名的恼火。
“你对身处此处的我有什么不满么？你们是哥布林，我是人类。讨伐你们是理所当然的。”
哥布林骑士们眼露凶光，看起来恨不得把我撕碎。
但是哥布林王抬抬手，制住它们。
“这只是一个交易，我希望你能接受。”

到做选择的时候了:
[[“我明白了，我会离开，把东西给我”]]。
[["我会杀了你，然后把东西带走"]]。


:: 和卡尔战斗之后 {"position":"725,2425","size":"100,100"}
<<if $karl.hp < 1>><<goto '击败卡尔剧情'>><</if>>\
=战败=

“靠幸运被选中的家伙，终归只有这点实力吗，”卡尔说，将染血的喋血者插入地面，”索尔坦那家伙，居然被你杀掉，真是有够好笑。“

兜帽跑过来观察你的伤势，沉默了一下，小声说到，”看来不需要治疗呢。“
但还是发动了微弱的治疗魔法，以骗过卡尔的眼睛。

”你这家伙，“卡尔眯了眯眼睛，说，”什么时候多了个同伴？还是治疗师，<span class="orange">是想把她当成梅利的替代吗</span>？“

”这一切都是命运的安排，我将成为最后的勇者，“卡尔说，”走吧，我不会在这里处决你，到行刑场去。——戴兜帽的家伙，我不知道你怎么溜进来的，不过我劝你还是离他远一点，他是个疯子。“

”说这样冠冕堂皇的话，你自己又算得上是什么东西呢？“兜帽说。
”哦？你又知道我的什么？“
”我全都知道，透过$me.name的眼睛，全都看到了“，兜帽抬起脸来，右眼散发出微弱的，令人怀念的光芒。你马上明白了，那正是你的眼睛。
”索尔坦是个人渣，而你只是他的狗而已。“兜帽毫不留情地说。

”住口！“卡尔挥动巨剑猛地砍下，在地上凿出个深坑。
”全他妈是蠢货，你也是他也是，连索尔坦为什么这样做都不知道，就擅自把他贬为恶人……”卡尔的脸色阴沉，“如果你们知道他这样做是为了拯救所有人，你还能说出这样的话吗！？“
”<span class="orange">我只要知道你们对梅利做的事情就够了</span>。“兜帽说。
沉默。
”你是……”卡尔目不转睛地盯着兜帽，说“那时候的孩子，我想起来了，梅利的妹妹。“

卡尔稍稍向前探出身子，说，”我不知道你看了什么，我自始自终都没想伤害梅利。索尔坦确实太过粗鲁了，可是他那时正在气头上……比起这个，是$me.name杀死了梅利，你怎么还帮着他！？“
”他和你们不一样，“兜帽说，”他走在正确的道路上。“
卡尔脸色变得更加阴沉了。

沉默片刻，他转过身去，”走吧，先离开这里。“
”什么意思？”兜帽狐疑地问到。
“我会听你们的说辞，不过得先离开这里，在王国的军队抵达之前。”

[[跟上卡尔]]


:: 哥布林前哨站 {"position":"725,900","size":"100,100"}
<<set $normalGoblin.hp to $normalGoblin.max_hp>>\
=哥布林前哨站=

一个黑乎乎的洞口通往[[巢穴深处]]。

洞口外边稍微开阔一点的地方，四处站着一些无所事事的哥布林。
在黑暗的掩盖下，我们可以<<link "攻击哥布林" "战斗画面">>
	<<set $lastPassage to '哥布林前哨站'>>\
    <<set $enemyNames to ['normalGoblin']>>\
<</link>>而不会引起骚乱。
<<link "同时攻击3只哥布林" "战斗画面">>\
	<<set $lastPassage to '哥布林前哨站'>>\
    <<silently>>\
    <<script>>
        const G = State.variables;
        // spawn goblins
        G.enemyNames = []
        for (let i = 0; i < 3; i++) {
            const enemyName = 'normalGoblin_' + i;
            const goblinCloned = structuredClone(G.normalGoblin);
            goblinCloned.name = '平凡哥布林' + i + '号';
            G[enemyName] = goblinCloned;
            G.enemyNames.push(enemyName);
        }
    <</script>>
    <</silently>>\
<</link>>

地上躺着死去的同伴们的尸体。
仔细看的话能够发现，[[梅利的尸体在发光]]。

[[躲进岩石裂缝->哥布林巢穴裂缝]]
<<if $theGoblinKing.hp <= 0>>
🟢风风光光地[[离开哥布林巢穴]]
<</if>>


:: 哥布林巢穴裂缝 {"position":"600,775","size":"100,100"}
=狭窄的岩石裂缝=

昏暗的洞穴，空气中漂浮着腐肉和粪便的味道。

<<if not $consideredInCave>>
[[思考我现在应该做的事情]]
<<else>>
🟢前往[[哥布林前哨站]]。
<<if $theWallPenetrator.hp > 0 and $wallPenetratorTalked is false and random(100) < 100>>\
🟠如果我没看错的话，岩石里面长出来一个人。[[向他搭话->向穿墙者搭话]]
<<link "攻击穿墙者" "战斗画面">>\
	<<set $lastPassage to passage()>>\
    <<set $enemyNames to ['theWallPenetrator']>>\
<</link>>
<</if>>\
<</if>>\


:: 大厅 {"position":"700,375","size":"100,100"}
=大厅=

老旧木头房子的客厅。
从这里可以前往[[小屋前十字路口]]，[[起居室]]和[[老头的房间]]。

如果想要休息的话，我需要先返回起居室。

<<if $oldMan.hp > 0>>
客厅中央站着一个$oldMan.name。\
<<link "攻击" "战斗画面">>
	<<set $lastPassage to '大厅'>>\
    <<script>>State.variables.enemyNames = ['oldMan'];<</script>>
<</link>>
[[向老头搭话]]
<<else>>
客厅中央躺着$oldMan.name的尸体。
🟢现在，我可以从小屋前面的十字路口离开。
<</if>>


:: 大监狱304室 {"position":"600,1400","size":"100,100"}
=大监狱304室=

空气中漂浮着莫名的臭味，偶尔能听见不知哪儿传来的遥远哀嚎。
由于失去了双眼，我什么都看不见，但现在大概是深夜。

[[思考人生的意义]]
<<silently>>\
<<audio "golden_season" stop>>
<<audio "big_prison" loop play>>
<</silently>>\


:: 小屋前十字路口 {"position":"725,525","size":"100,100"}
=小屋前十字路口=

从这里可以看见破烂的[[小屋->大厅]]，和小屋背后的[[低矮林地]]。

大马路如此笔直，它一定可以带我去往任何地方。

<<if $oldMan.hp < 1>>
🟢是时候[[离开这里]]了。
<</if>>


:: 巢穴深处 {"position":"900,900","size":"100,100"}
=<<print passage()>>=

哥布林巢穴深处，莫名的腐臭更加严重了。

<<if $theOutpostMountainGoblin.hp > 0>>\
一只拿着火把的<span class='red'>大块头哥布林</span>在巡逻。<<link "攻击大个子哥布林" "战斗画面">>
	<<set $lastPassage to '巢穴深处'>>\
    <<set $enemyNames to ['theOutpostMountainGoblin']>>\
<</link>>\
<<else>>\
地上躺着大块头哥布林的尸体。
🟢现在我可以前往祭坛，[[王之间]]。
<</if>>

返回[[哥布林前哨站]]。


:: 思考人生的意义 {"position":"725,1400","size":"100,100"}
我没有记忆，对于过去的自己一无所知。
而有记忆的时间太短，以至于几乎没有活着的实感。

不仅是自己的生命，有时我觉得这个世界并不真实——就像那天在哥布林巢穴看见的景象那样。
可是生活在这个世界的人们，难道没有一丁点价值吗？
不……
他们有自己的生活，有自己的欲望。
和我怎么想没有关系，他们的生命有真实的重量。

”那你为什么要将他们杀死呢？“
每个人都这样问我。
而现在的我只能给出这样的答案：<span class="orange">因为我比任何人都要自由，而维护这样的自由，难道不是我的使命吗？</span>

如果这个世界是虚构的，那它的作者一定是个天才。他赋予我的使命就是背叛，背叛，不停地背叛，然后死去，甚至连感情线都没有给我安排，多么波澜壮阔的一生！
所以我要做的就是，在这里死去，再一次背叛所有人的期待。

[[自杀]]


:: 思考我现在应该做的事情 {"position":"600,900","size":"100,100"}
选择永远只有两种，前进，或者是后退。

如今付出了惨重的代价，我已经失去了后退的选项。
我必须取下哥布林王的头颅，以此凭吊死去的队友们。

[[返回->哥布林巢穴裂缝]]
<<script>>
State.variables.consideredInCave = true;
<</script>>


:: 战斗画面 {"position":"1000,225","size":"100,100"}
=战斗=
<<silently>>\
<<script>>
console.log('Second check');
const enemies = State.variables.enemyNames.map(name => State.variables[name]);
const isGroupAlive = group => group.some(obj => obj.hp > 0);
State.variables.enemyNameString = ''
enemies.map(obj => State.variables.enemyNameString += obj.name + ' ')
if (!isGroupAlive(enemies)){
	console.log('Enemies All Dead!');
    State.variables.error = true;
}else{
	State.variables.error = false;
	// 处理主角的power和resistance
	const me = State.variables.me;
	me.power = me.intrinsicPower + me.weapon.power;
	me.resistance = me.intrinsicResistance + me.armor.resistance;
	const us = [me];
	const usCopy = us.map(dd => fightObjectCopy(dd));
	// 处理敌人的objCopy
    const enemiesCopy = enemies.map(enemy => fightObjectCopy(enemy));
	// 2024.10.21 增加指环效果
	const cb = {'g1': {}, 'g2': {}};
	for (let i = 0; i < us.length; i++){
		const ally = us[i];
		if (ally.legacy){
			cb['g1'][i] = {}
			if (ally.legacy.damageCalculator){
				cb['g1'][i]['damageCalculator'] = ally.legacy.damageCalculator;
			}
			if (ally.legacy.groupModifier){
				cb['g1'][i]['groupModifier'] = ally.legacy.groupModifier;
			}
			if (ally.legacy.deadCallback){
				cb['g1'][i]['deadCallback'] = ally.legacy.deadCallback;
			}
			// 2024.11.19 增加伤害减缓器
			if (ally.legacy.damageReductor){
				cb['g1'][i]['damageReductor'] = ally.legacy.damageReductor;
			}
		}
	}
	// 2024.10.27 循环为敌人设置callback函数
	for (let i = 0; i < enemies.length; i++){
		const enemy = enemies[i];
		if (enemy.legacy){
			cb['g2'][i] = {}
			if (enemy.legacy.damageCalculator){
				cb['g2'][i]['damageCalculator'] = enemy.legacy.damageCalculator;
				console.log('为'+enemy.name+'设置了伤害计算回调!');
			}
			if (enemy.legacy.groupModifier){
				cb['g2'][i]['groupModifier'] = enemy.legacy.groupModifier;
				console.log('为'+enemy.name+'设置了组回调!')
			}
			if (enemy.legacy.deadCallback){
				cb['g2'][i]['deadCallback'] = enemy.legacy.deadCallback;
				console.log('为'+enemy.name+'设置了死亡回调!')
			}
			// 2024.11.19 增加伤害减缓器
			if (enemy.legacy.damageReductor){
				cb['g2'][i]['damageReductor'] = enemy.legacy.damageReductor;
			}
		}
	}
	const fightHistory = groupFight(usCopy, enemiesCopy, cb);
    // Added 2024.10.27 merge battle log.
    const neetFightHistory = window.mergeBattleLogs(fightHistory);
	State.variables.fightHistory = neetFightHistory; // 用于后续展示记录
	window.temp = neetFightHistory;
	// console.log(fightHistory);
	State.variables.me.hp = usCopy[0].hp;
    for (let i = 0; i < enemies.length; i++) {
        enemies[i].hp = enemiesCopy[i].hp;
    }
    console.log(enemies[0])
	State.variables.enemy = enemies[0];  //考虑到兼容性问题
}
<</script>>
<</silently>>\

<<if $error>>\
	$enemyNameString已经死了，请不要反复鞭尸！
<<else>>\
向$enemyNameString发起了攻击！
<<if $me.hp < 1>>\
<<goto "死亡">>\
<<else>>\
<span class='good'>$enemyNameString被你杀死了！</span>
<<include '物品掉落'>>
<<include '杀死怪物回调'>>
<<button "查看战斗记录">><<set _temp to $showDialogFightHistory()>><</button>>
<</if>>\
<</if>>\

<<link "返回" $lastPassage>><</link>>


:: 杀死剜眼者后剧情 {"position":"975,1775","size":"100,100"}
杀死剜眼者给你一种从未有过的奇妙感觉，就像是找回了丢失掉很久的宝物那样的感觉。
但是你没能沉浸在这余韵中很久。

“你的眼睛已经失去了，失去的东西毕竟再也找不回来。”兜帽说，“我在地上捡到两个玻璃球，你就先装上它们吧。”
放到你掌心，两个冰凉的玻璃球。
“擦干净了吗？”
”……“

大小形状刚刚好——也许有些圆过头了——可是为什么不呢，总比没有眼球好。
于是你把它们塞进自己的眼眶，一阵钝痛过后，你看见了一些东西。

[[一些东西]]

<<silently>>\
<<script>>
	const G = State.variables;
	addItem(G.inventory.items, G.glassEyeBall);
    G.showDialog('获得物品', '获得了' + G.glassEyeBall.name + '!');
<</script>>
<</silently>>\


:: 杀死怪物回调 {"position":"1250,425","size":"100,100"}
<<silently>>\
<<script>>
const G = State.variables;
G.enemyNames.map(varName => {
	G.addExp(G[varName].exp);
    if (varName.startsWith('slime')){
        console.log('杀死史莱姆')
        addItem(State.variables.titles.items, State.variables.slimeSlayer, 1)
    }else if (varName == 'oldMan'){
        console.log('杀死老头')
        if (!checkHavingItem(State.variables.titles.items, '俄狄浦斯')){
            addItem(State.variables.titles.items, State.variables.oldManSlayer)
        }
    }else if (varName == 'theOutpostMountainGoblin'){
        if (!State.variables.me.legacy || State.variables.me.legacy.name != '破甲指环'){
            console.log('不使用破甲戒指击破山岭哥布林');
            const title = {name: '手撕重坦者', desc: '不使用破甲戒指击破前哨站的山岭哥布林。'}
            addItem(State.variables.titles.items, title)
        }else{
            const title = {name: '封弊者', desc: '使用破甲戒指击破前哨站的山岭哥布林。'}
            addItem(State.variables.titles.items, title);
        }
        console.log('杀死前哨站的山岭哥布林');
    }else if (varName == 'theGoblinKing'){
        if (!State.variables.me.goblinKingTalked){
            console.log('背信弃义者');
            const title = {name: '背信弃义者', desc: '你的良心不会痛吗？'}
            addItem(State.variables.titles.items, title)
        }else{
            const title = {name: '战斗狂', desc: '杀死哥布林王。'}
            addItem(State.variables.titles.items, title);
        }
        console.log('杀死哥布林王');
    }else if (varName == 'theWallPenetrator'){
    	const title = {name: '趁人之危', desc: '杀死不明所以的穿墙者。'}
        addItem(State.variables.titles.items, title);
    }
})
<</script>>
<</silently>>\


:: 梅利的尸体在发光 {"position":"725,1025","size":"100,100"}
梅利是我们队伍中的牧师。
她给自己施加了诅咒，一旦死亡就会近乎永久地为四周施加治疗光环。
如果稍微靠近就能够回复健康。

<<link "使用梅利进行治疗" "梅利的尸体在发光">><<set $temp to $healMySelf(0.05)>><</link>>
[[返回->哥布林前哨站]]


:: 死亡 {"position":"1125,250","size":"100,100"}
<<silent>>
<<script>>
console.log('回复怪物的血量');
const enemies = State.variables.enemyNames.map(name => State.variables[name]);
enemies.map(obj => {obj.hp = obj.max_hp});
<</script>>
<</silent>>\
=死亡=

<span class='danger'>你被$enemy.name杀死了！</span>
$enemy.name的HP剩余$enemy.hp点，下次再努力吧。
<span class='important'>你必须活下来。</span>

<<button "查看战斗记录">><<set _temp to $showDialogFightHistory()>><</button>>

<<button "满血复活（使用禁忌的时间回溯魔法）">>\
<<set _deadMark to {name: '死神的印记', desc: '继续你的旅途，这双眼睛会注视着你'}>>\
<<set _temp to addItem($inventory.items, _deadMark)>>\
<<set $me.hp to $me.max_hp>>\
<<goto $lastPassage>>\
<</button>>

或者你也可以点击侧边栏的"RESTART"重新开始游戏。


:: 混乱的终幕 {"position":"975,2150","size":"100,100"}
视野很狭窄。
具体来说，只是一条缝隙。
如果靠近的话，能看得稍微宽一点。

这该死的女人！
男人一巴掌把女人扇倒在地，纸张焚烧后留下的灰烬被扬起，四处飞散。
你那么想死是吧，那我就成全你。
又是一脚踹在她的侧腹，女人被踹翻几圈，艰难地撑起半个身子，干呕起来。

别碍事，男人猛地挣开同伴的劝阻，她就是个婊子，下贱玩意。
男人走过去，猛地抓起女人的额发，让她露出痛苦的表情，就像要展示给同伴看一样。
你看她这表情，她都不知道多享受呢……啊，我懂了，你也想玩是吧，男人露出卑劣的笑容，行啊，横竖我都得杀了她，今天就给你爽爽，好歹你也做了我那么多年的跟班，你过来。
女人痛苦地挣扎起来。

[[……->红色的闭幕]]


:: 片刻之后 {"position":"475,1150","size":"100,100"}
稍过片刻，传来了小小的当啷声，好像有什么东西掉在了地上。
难道说是刚刚那人说的东西吗？

在地上摸索了一下，<span class='good'>找到了一枚指环</span>。

[[返回->哥布林巢穴裂缝]]
<<silently>>\
<<script>>
	addItem(State.variables.inventory.items, State.variables.armorPiercingRing);
    State.variables.wallPenetratorTalked = true;
    State.variables.showDialog('获得物品', '获得了' + State.variables.armorPiercingRing.name + '!');
<</script>>
<</silently>>\


:: 物品掉落 {"position":"1125,375","size":"100,100"}
<<silently>>\
<<script>>
State.variables.dropLog = '';
const enemies = State.variables.enemyNames.map(name => State.variables[name]);
enemies.forEach(enemy => {
    if ('drops' in enemy) {
        // 随机计算掉落的物品
        let items = dropItems(enemy.drops);
        console.log(items);

        // 生成掉落信息文本并追加到temp中
        if (items.length > 0){
        	let text = dropString(items);
        	State.variables.dropLog += enemy.name + '掉落了' + text + '\n';  // 添加换行符，便于区分多个敌人掉落的信息
            addToInventory(State.variables.inventory.items, items);
        } else {
        	State.variables.dropLog += enemy.name + '什么都没有掉落就离开了这个世界\n'
        }
    } else {
    	State.variables.dropLog += enemy.name + '不存在可掉落的物品。'
    }
});
<</script>>
<</silently>>
<span class='good'>$dropLog</span>


:: 物品栏 {"position":"875,100","size":"100,100"}
<<for _i, _item range  $inventory.items>>
	<<if _item.count > 0>>
    	名称: _item.name x _item.count <<if _item.useCallback>><<print '<<link "使用" "物品栏">><<set _temp to $globalUseCallback(' + _i + ')>><</link>>'>><</if>>
        _item.desc
    <</if>>
<</for>>

<<return "返回">>


:: 王之间 {"position":"900,1025","size":"100,100"}
=<<print passage()>>=

宽敞的石室，两边挂着炽烈燃烧的火把，
和哥布林巢穴格格不入的光景。

<div class="aa">
{{{
                                           
      ::-..    :.          :.   ..-::      
   . . ..       +@@@@@@@@@%        :   :   
    -::      @@**          *%@%     .:=.   
  :.:.    #@@  %  @@@@@@@% @* +@@    . .:. 
    .    @@@@    @@@@%%@@@:   @@@+*   .    
 =      =@%   @@@@ =@@@@ +@@@:  =@%        
 @ @:  %@@  @@@  = .: .:--  +@@  *@@   @ % 
 @%@@      @@  :*#%%%%@%%*#:  =@  + : @@@@ 
       @   @  -==**%@@@%@#*#*. +@  %@      
      +@@@@. ==+%%@@@@@@@%%*==  @ @@@      
  =   :   @@ ===*+@     %#**+= =@   %   @  
 %    @   @  =*@@%@ =*+:=@%*==   =  @  @   
 #    @   @*.= -*-- ++=+ %*@*+:.@@  @  @@  
 @ =  @   @==@@@@@+ ++=+ @@@@@@ @%  @ @@@: 
 @@@@ @   @@@@@@@@= ==== @%@@@@-@@  @ :@@@ 
 % @  @  :@ #:*%#:  =--- ***% % @@  @:   : 
 :    @  %@    =-**      %:=    :@  @%     
      @   .                     @   %      
 =@+       @@@@@@@@@@@@@@@@@@@@@@      :@* 
       @@@@@@@@@@@@@@@@@@@@@@@@@@@@@       
   #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@   
}}}
</div>

石室深处摆着一张石椅——看样子是直接从岩壁上凿出来的，
<<if $theGoblinKing.hp > 0>>\
上面坐着一只头戴王冠的哥布林。

哥布林王。
它正是我身处此地的原因。
我要杀死它，为死去的同伴们复仇。
然后离开这个令人不快的地方。

只不过，在能够靠近它之前，还有不得不对付的敌人——三只哥布林骑士。
它们给人的感觉和外边的哥布林完全不一样。

它们已经发现了我这个闯入者，但却按兵不动。
因为哥布林王制止了它们。
<<else>>\
🟢上面有着哥布林王的尸体。
<</if>>

<<if $theRouletteEscort.hp > 0>>\
<<link "🔴攻击哥布林轮盘搀扶者" "战斗画面">>\
	<<set $theRouletteEscort.hp to $theRouletteEscort.max_hp>>\
	<<set $lastPassage to passage()>>\
    <<set $enemyNames to ['theRouletteEscort']>>\
<</link>>
<<else>>\
🟢骑士之一的哥布林轮盘搀扶者已经死亡。
<</if>>\
<<if $theArmorBreaker.hp > 0>>\
<<link "🔴攻击哥布林破甲者" "战斗画面">>\
	<<set $theArmorBreaker.hp to $theArmorBreaker.max_hp>>\
	<<set $lastPassage to passage()>>\
    <<set $enemyNames to ['theArmorBreaker']>>\
<</link>>
<<else>>\
🟢骑士之一的哥布林破甲者已经死亡。
<</if>>\
<<if $theSelfDestructor.hp > 0>>\
<<link "🔴攻击哥布林自爆者" "战斗画面">>\
	<<set $theSelfDestructor.hp to $theSelfDestructor.max_hp>>\
	<<set $lastPassage to passage()>>\
    <<set $enemyNames to ['theSelfDestructor']>>\
<</link>>
<<else>>\
🟢骑士之一的哥布林自爆者已经死亡。
<</if>>
<<if $theRouletteEscort.hp <=0 and $theArmorBreaker.hp <=0 and $theSelfDestructor.hp <=0 and $theGoblinKing.hp > 0>>
<<link "🔴攻击哥布林王" "战斗画面">>\
	<<set $theGoblinKing.hp to $theGoblinKing.max_hp>>\
	<<set $lastPassage to passage()>>\
    <<set $enemyNames to ['theGoblinKing']>>\
<</link>>
<</if>>

<<if not $goblinKingTalked and $theGoblinKing.hp > 0>>🟠[[听哥布林王说话]]<</if>>
<<if $theGoblinKing.hp <= 0>>\
🟢现在我可以从前哨站离开。
<<else>>\
🟠击败哥布林王后可以从前哨站离开。
<</if>>
返回[[巢穴深处]]


:: 王国旅行指南 {"position":"1000,400","size":"100,100"}
翻开一看，里面的书页全都被撕掉了，只剩下一张纸，上面潦草地写着：

<blockquote>
在大洪水来临之前，离开这里
<small>PS: 我把书全都撕了，因为你是自由的</small>
</blockquote>

[[老头的房间]]


:: 祭坛 {"position":"1025,1025","size":"100,100"}
(游戏进度暂时只到这里)

[[巢穴深处]]


:: 离开哥布林巢穴 {"position":"600,1025","size":"100,100"}
在洞窟里待久了，外边的阳光十分刺眼。
可是还有比阳光更加刺眼的东西——齐刷刷的盔甲反射阳光，令人眼花缭乱。
等待我的是整齐的军队。

<div class="aa">
{{{
&&&x;;x;x$+.+  ..       :;..;&X.;:.X
&&&+:;X+X$;;+:.:..      :+..+x&.;; $
&&&;..X+$&;+x:.x.       .+. ;x&:.;:$
&&&;. X+$&:+. .x.:.     :;. :.&x:;x&
&&&;. $+$&.x. .x.       .x:.+:X$::x$
&&&+. $x$&.X. .x.       .x..+.;&;:x&
&&&+. $x$&.X...+.       .x:.+..&$;x&
&&&x..Xx&&.$..::.        x;.+.:X&;x&
&&&+. $x&&:$. ::.        x;.+.:X&;x&
&&&;..$+&&:X. ;:.        x+.+::x&;X&
&&&+..&&&&:+. ; .X&      xxxx::+&+XX
&&&;.&&&&&+&;$X&X&$&$X$x$x&&&;:;&x$&
&&&:x&&&&&&&X&&&&&&&$&&&&&&&X:..$$X&
&&$:$&&&&&&&&&&&&&&&&&&&&&&$$:::;+X&
&&X+&&&&&&;:.::X+$&$:;;:&&&&&:::::;:
&X$.xX..&+......:;++;::..::::::::X;.
$:..::;xxx;;:.........    ...:..::.:
XX$X++;::;.....:.:.::..........::..;
$++&X&&&x::.::::.:::;::::..:...:.::.
}}}
</div>

从军队中站出来一个男人，他的头上缠着厚厚的绷带。

“哟，卡尔，你来迎接我了吗？”我说，“用不着那么大排场的”。

沉默。

“你为什么露出这样的表情？”我说，“到底发生了什么事，是遇到了一种特殊的，永远无法弥补的不幸吗？我们真的无法从中恢复过来了吗？一切都完蛋了吗？”

“你为什么要做出<span class='red'>这样的事情</span>？”卡尔问。

“[[这样的事情]]？”


:: 离开这里 {"position":"600,650","size":"100,100"}
= 第二章 =

(半年后)

[[继续->哥布林巢穴裂缝]]

<<script>>
let G = State.variables
G.consideredInCave = false;
healing(G.me, 1.0); // 回复满hp
healing(G.me, -0.4); // 设置为60%HP
addItem(G.inventory.items, G.smallHealingPotion);
// G.me.weapon = G.bloodedIronSword;
G.me.weapon = G.default_weapon;
G.me.armor = G.bloodedDeerskinArmor;
G.wallPenetratorTalked = false; //是否遇见穿墙者
G.goblinKingTalked = false; //是否与哥布林王交谈
const geniusScientistLeft = '天才学者的悲鸣';
G[geniusScientistLeft] = {name: geniusScientistLeft, desc: '除了我想知道的东西，没有什么是重要的。'}
G.theWallPenetrator = {
	name: '穿墙者', 
    exp: 10,
    max_hp: 10,
    hp: 10, 
    power: 10, 
    resistance: 10, 
    drops: [{
    	item: G[geniusScientistLeft], 
        chance: 1.0
    }]
}
G.rouletteV1DamageCalculator = function (me, enemy, fightHistory = []) {
    fightHistory.push(me.name + '转动了命运之轮!');
    
    // 随机生成1到6之间的整数
    const dice = Math.floor(Math.random() * 6) + 1;
    let tarot = '';
    let damage = 0;
    
    // 根据骰子结果确定塔罗牌类型和伤害值
    if (dice >= 1 && dice <= 3) {
        tarot = '倒吊人';
        damage = 0; // 伤害为0
    } else if (dice >= 4 && dice <= 5) {
        tarot = '战车';
        damage = Math.floor(enemy.max_hp * 0.4); // 伤害为敌人生命值的40%
    } else if (dice === 6) {
        tarot = '死神';
        damage = Math.floor(enemy.max_hp * 1.2); // 伤害为敌人生命值的120%
    }

    // 将塔罗牌结果加入战斗历史
    fightHistory.push('指针停留在<span class="purple">' + tarot + '</span>!');

    // 返回计算后的伤害值
    return damage;
}
G.useRouletteV1 = () => {
	window.G.me.legacy = G.rouletteV1;
	window.G.showDialog('装备遗物', '成功装备了' + G.rouletteV1.name + '!');
}
G.rouletteV1 = {name: '命运转轮', desc: 'Alive or Dead?\n1~3:倒吊人，造成0点伤害\n4~5:战车，造成40%最大生命值的伤害\n6:死神，造成120%最大生命值的伤害\n可是我似乎用不了它。', damageCalculator: G.rouletteV1DamageCalculator, useCallback: G.useRouletteV1};
G.theRouletteEscort = {
	name: '哥布林轮盘搀扶者', 
    exp: 500,
    max_hp: 80,
    hp: 80, 
    power: 0, 
    resistance: 0, 
	legacy: G.rouletteV1,
    drops: [{
    	item: G.rouletteV1, 
        chance: 1.0
    }]
}
// 哥布林破甲者
G.fullDamageCalculator = function (me, enemy, fightHistory = []) {
    fightHistory.push(me.name + '使用了穿墙者!');
    return me.power;
}
G.fullArmorBreaker = {name: '穿墙者', desc: '无视防御。某种天赋的具象化。', damageCalculator: G.fullDamageCalculator};
G.theArmorBreaker = {
	name: '哥布林破甲者', 
    exp: 500,
    max_hp: 150,
    hp: 150, 
    power: 17, 
    resistance: 0, 
	legacy: G.fullArmorBreaker,
    drops: [{
    	item: G.fullArmorBreaker, 
        chance: 1.0
    }]
}
// 哥布林自爆者
G.theSelfDestructorCb = function (us, they, fightHistory = [], info = {}) {
    fightHistory.push(info.me.name + '自爆了!');
    for (let he of they){
		const bombPower = 200;
		const damage = bombPower - he.resistance;
		fightHistory.push(`<span class="red">${info.me.name}的自爆对${he.name}造成了${damage}点伤害!</span>`)
		he.hp = Math.max(0, he.hp-damage);
		console.log(`${he.name}的hp被重新设置为${he.hp}`)
	}
}
G.theSelfDestructorLegacy = {name: '自爆者', desc: '对每个敌人造成100点伤害。某种天赋的具象化。', deadCallback: G.theSelfDestructorCb};
G.theSelfDestructor = {
	name: '哥布林自爆者', 
    exp: 500,
    max_hp: 5,
    hp: 5, 
    power: 1, 
    resistance: 1, 
	legacy: G.theSelfDestructorLegacy,
    drops: [{
    	item: G.theSelfDestructorLegacy, 
        chance: 1.0
    }]
}
// 哥布林王
G.realGoblinKingRodName = '真*哥布林王权杖'
G.realGoblinKingRodGroupModifier = (group1, group2, fightHistory) => {
	const rodName = G.realGoblinKingRodName;
	const prototFightObj = State.variables.mountainGoblin;
	const familiarName = '【使魔】山岭哥布林';
	for(let i = 0; i< 5; i++){
		const spawned = fightObjectCopy(prototFightObj);
		spawned.name = `${familiarName}${i}号`;
		group1.push(spawned);
		console.log(rodName + '为' + group1[0].name + '的队伍召唤了' + familiarName + '!');
		fightHistory.push(rodName + '为' + group1[0].name + '的队伍召唤了' + familiarName + '!');
	}
}
G[G.realGoblinKingRodName] = {name: G.realGoblinKingRodName, desc: '在我的王之力面前颤抖吧！\n已损坏。', groupModifier: G.realGoblinKingRodGroupModifier};
G.theGoblinKing = {
	name: '哥布林王', 
    exp: 500,
    max_hp: 5,
    hp: 5, 
    power: 1, 
    resistance: 1, 
	legacy: G[G.realGoblinKingRodName],
    drops: [{
    	item: G[G.realGoblinKingRodName], 
        chance: 1.0
    }]
}

// ======================= 一些剧情变量2024.12.16 =====================
G.knifeGot = false;
G.bloodedDagger = {name: '血迹斑斑的匕首', desc: '爱用的匕首。\n已经无法使用。'};
<</script>>

<<silently>>\
<<cacheaudio "golden_season" "mp3|https://zhuobinggang.github.io/game/audio/golden_season.mp3">>
<<audio "golden_season" loop play>>
<</silently>>\


:: 称号栏 {"position":"1000,100","size":"100,100"}
<<for $i, $item range  $titles.items>>
	<<if $item.count > 0>>
    	《$item.name》<<if $item.count > 1>>x $item.count<</if>>
        $item.desc
    <</if>>
<</for>>

<<return "返回">>


:: 穿过窄门 {"position":"725,2025","size":"100,100"}
一条阴冷，漫长，狭窄的石头通道。

石墙上，间隔很远地摆放着散发出微弱亮光的火把。

仿佛没有尽头的石头通道。

[[前进]]


:: 第三巡逻点 {"position":"725,1650","size":"100,100"}
=第三巡逻点=

这似乎是一个宽敞的空间。
透过两个空洞的眼窝，我觉察到这里散布着人形的黄色灵魂，以及在地上匍匐前进的黄色灵魂。
看来有一些东西是失去了视力才能够看见的。

在我旁边自称“兜帽”的人的灵魂则是白色的。

<<link "让兜帽给我治疗" "第三巡逻点">><<set $temp to $healMySelf(0.5)>><</link>>
<<link "攻击黄色灵魂" "战斗画面">>\
	<<set $prisonGuard.hp to $prisonGuard.max_hp>>\
	<<set $lastPassage to passage()>>\
    <<set $enemyNames to ['prisonGuard']>>\
<</link>>
<<link "同时攻击三个黄色灵魂" "战斗画面">>\
	<<set $prisonGuard.hp to $prisonGuard.max_hp>>\
	<<set $lastPassage to passage()>>\
    <<silently>>\
    <<script>>
        const G = State.variables;
        // spawn goblins
        G.enemyNames = []
        for (let i = 0; i < 3; i++) {
            const enemyName = 'prisonGuard_' + i;
            const prisonGuardCloned = structuredClone(G.prisonGuard);
            prisonGuardCloned.name = '监狱守卫' + i + '号';
            G[enemyName] = prisonGuardCloned;
            G.enemyNames.push(enemyName);
        }
    <</script>>
    <</silently>>\
<</link>>

<<if $theWolfTrainer.hp > 0>>\
在空间的深处，能看到一对红色的灵魂。
“看来我们必须击败看守人才能离开，”兜帽说。
<<link "🔴攻击红色灵魂" "战斗画面">>\
	<<set $theWolfTrainer.hp to $theWolfTrainer.max_hp>>\
	<<set $lastPassage to passage()>>\
    <<set $enemyNames to ['theWolfTrainer', 'theWildWolf']>>\
<</link>>
<<else>>\
对现在的你来说，这种程度的敌人已经不成问题了。
可是这样的胜利又有什么意义呢？
🟢红色灵魂已经消散。现在我们可以前往[[行刑室]]。
<</if>>\


:: 第四章 {"position":"725,2675","size":"100,100"}
=第四章=

(施工中……)


:: 红色的闭幕 {"position":"975,2275","size":"100,100"}
四周终于安静了下来。
只有液体滴落的声音。
你看向自己的右手，红色的液体正从刃尖上滴落。
你随手把匕首一扔，感到有些疲惫，便向着那边的岩石裂缝走去，打算在那温暖的石床上躺下。

温柔的黑暗笼罩了你。
手黏糊糊的让人有点不舒服，但只是一点小事而已。
就这样意识逐渐沉向深渊。

[[……->半梦半醒]]


:: 老头的信 {"position":"1000,550","size":"100,100"}
你看到这封信的时候，我大概已经死了吧。
你肯定以为这老头房间里藏着不得了的东西，
结果只发现了这封信。

一定很失望吧。
如果是我的话一定会很失望。

不过你肯定会想：“这封信一定藏着关于我的身世的不得了的秘密”。

是的，我会告诉你一切真相。

[[下一页]]


:: 老头的房间 {"position":"850,425","size":"100,100"}
=老头的房间=

<<if $oldMan.hp > 0>>
老头： 站住。谁允许你随便进我的房间了？

看来<span class='red'>要想进去还得想想办法</span>。
<<else>>
煞风景的房间。
家具和我自己的起居室差不多，一张床，一张桌子而已。
桌子上摆着[[一封信->老头的信]]，和一本《[[王国旅行指南]]》。
<</if>>


[[大厅]]


:: 自杀 {"position":"725,1525","size":"100,100"}
“停停停，你想干什么？”
本该无人的牢房里，有人这样对我说了。
那人是什么时候出现的呢？
“谁在那里？”

“我？你可以叫我兜帽。跟我来，我们去夺回你失去的东西。”

[[跟上兜帽->第三巡逻点]]


:: 行刑室 {"position":"725,1775","size":"100,100"}
=行刑室=

漂浮着令人作呕的浓重血腥味的空间。

<<if $theEyeScooper.hp > 0>>\
空间中央存在着一个[[不祥的红色灵魂]]。
<<else>>\
🟢红色灵魂已经消散。
你能够看见东西了。你获得了对这个空间的审美愉悦。
🟢现在我们可以[[前往窄门]]。
<</if>>

<<if $theEyeScooper.hp < 1 and not $plotAfterKillEyeScooperRead>><<goto '杀死剜眼者后剧情'>><</if>>

返回[[第三巡逻点]]


:: 起居室 {"position":"700,250","size":"100,100"}
=起居室=

<div class="aa">
{{{
                                    
    :----========                   
    =#++++***++**                   
    :-::::::::::::::                
    :%=:::::::::::::::.             
    .-#=:::::::::::::::::.          
      .#=:::::::::::::::::::.       
       .#+::::::::::::::::====*:.   
        .%*--=***#%%%%%%%%%%%%%%=   
        .:#%####%%%%%%%%%#+==-%%:   
         .:*##*+==--:::::::::=%*    
          .*%#--::..                
           *%#..                    
                                    
}}}
</div>

一个小小的房间，整洁，也可以说是没有什么生活气息。 
一张床，一张椅子，桌子。
桌子上面放着[[一本翻开的书]]，还有蜡烛燃尽留下的烛泪。

<<if not $beginnerWeaponGot>>\
墙上挂着一柄$beginnerWeapon['name']。\
<<link "装备" "起居室">>\
<<set $me.weapon to $beginnerWeapon>>\
<<set $beginnerWeaponGot to true>>\
<</link>>\
<<else>>\
🟢墙上放武器的地方空空如也。\
<</if>>\

<<if not $beginnerArmorGot>>\
墙上挂着一套$beginnerArmor['name']。\
<<link "装备" "起居室">>\
<<set $me.armor to $beginnerArmor>>\
<<set $beginnerArmorGot to true>>\
<</link>>\
<<else>>\
🟢墙上放防具的地方空空如也。\
<</if>>\


[[休息]]
到[[大厅]]去。


:: 跟上卡尔 {"position":"725,2550","size":"100,100"}
=跟上卡尔=

“这边有通往商店街的地下通道，”卡尔回过头说，“赶紧过来。”

正当兜帽搀扶着你站起，抬起头来的时候——卡尔的身影消失了。
一切发生得过于迅速，以至于无法理解。

沉重的击打声，木头砸在盔甲上的声音。
数秒后才传来卡尔的落地声。
他被什么东西击飞了。

微弱月光照亮的，银梯周围的一小块地方。
也就是刚刚卡尔站着的地方。
“那个东西”终于现出了原型。

一个披着破烂风衣的巨大身影，以及肩上扛着的巨大木头十字架。
<span class="red">那正是一直潜伏在黑暗之中，一开始感受到的压迫感的源头</span>。

“那是守墓人，”兜帽说，“地下世界的引路人。”

守墓人将十字架用右手托住，高高举起，展示出投掷的姿态。
当意识到他要做什么的时候——糟糕了，你不禁这样想——已经躲不掉了。
“你会找到真相的，”兜帽说。
然后你感到身体腾空，兜帽用全身的力气把你撞开。
破空之声传来，强劲的气流掀起你的额发。
咚的一声，碗口粗的木头把兜帽的胸脯刺穿，倾斜着把她钉在黑色柔软的土地上。
大量的红色液体从她的胸口，还有嘴角汩汩流出。

还没来得及发出感慨，守墓人便朝你走了过来，伴随着沉重的脚步声，你挣扎着爬起，却被他一脚踢飞。
内脏大量破损——致命伤。
但是没关系，只要重新来过就好了，于是你又站了起来。
可是还没等你站起，你便感到失重——守墓人用巨手将你抓起，狠狠地往地面拍去。
这一击就没有那么好受了，你的五脏六腑和脑浆喷洒了一地。
……
…

[[……->第四章]]


:: 这样的事情 {"position":"600,1150","size":"100,100"}
“<span class='red'>你杀了梅利和索尔坦</span>。”卡尔说。

梅利和索尔坦——我当然知道他们是谁。

“你在说什么，我怎么会忍心杀死最好的朋友？”$me.name悲痛地说，“你有什么证据证明是我干的吗？”

卡尔的表情扭成一团，说，“我无法理解你，<span class="orange">你为什么会做出这样的事情？</span>……你要证据？”
一柄染血的匕首被扔出，框当一声落在$me.name的脚边。

<<if not $knifeGot>>\
<<link "拾取" "这样的事情">>
<<silently>>\
<<script>>
	addItem(G.inventory.items, G.bloodedDagger);
    G.knifeGot = true;
    G.showDialog('获得物品', '获得了' + G.bloodedDagger.name + '!');
<</script>>
<</silently>>\
<</link>>\
<</if>>\

“这不是我爱用的匕首吗？”$me.name说。

“不久前它还插在我的胸口。”卡尔说。

人群一片哗然。

“不要跟他废话了，”一个男人站出来说。
他的装备稍稍有些不同，看起来应该是他们的队长之类的。
“$me.name，”男人说，“如果可以的话，我真想把你就地正法，可我们毕竟是王国的正规军队…”

“我在和他说话，你能不要插嘴吗？”$me.name说。
男人愣了一下，像是要说些什么，但还是闭上了嘴巴。

"你想知道为什么？"$me.name径直朝着卡尔说。
卡尔怔怔地望着$me.name。
“因为有这样一个选项提供给我啊，点点看不是人之常情吗？”

“你疯了。”卡尔说。
“把他绑起来，带回去！”男人掷地有声地说道。

[[进入第三章]]


:: 进入第三章 {"position":"600,1275","size":"100,100"}
=王城法庭=

大法官： 前勇者$me.name，你被指控杀害队友，对此你有什么异议吗？

法官的话音刚落，嘈杂便在群众间传播开来。
有人对我加以唾骂，有人怀疑其中隐情，当然了，也有人单纯只是想要看戏。
昨天的勇者，今天的杀人犯，这种转折怎么能够错过？

于是我说： 我没有异议。
人群瞬间炸开了锅，有人开始朝我扔东西。肃静，肃静！法官用木锤敲击桌子砰砰作响。

法官：既然如此，请你具体说明自己的作案动机。坦诚相告对量刑有好处。
于是我说：我还杀了养育我的老头，那之后忘了收拾，尸体就摆在那里，希望房间别被弄的太臭。
当他们好不容易理解了我的意思——“这种人是怎么成为勇者的！”终于有人忍不住站起来对我怒吼。
这就是坦诚相告的结果吗？

就这样我被<span class='red'>剜掉双眼</span>，关进大牢，等待三天后的绞刑。

[[大监狱304室]]

<<silently>>
<<script>>
let G = State.variables;
// 训狼者：lv30 几率闪避
G['hermesBootsDamageReductor'] = function (enemy, me, damage, fightHistory = []) {
	let chance = 0.3;
    let randomChance = Math.random();
    if (randomChance <= chance) {
		fightHistory.push(me.name + '的赫尔墨斯靴被动触发并躲开了攻击!');
		damage = 0;
	}
	return damage;
}
G['hermesBoots'] = {name: '赫尔墨斯靴', desc: '30%几率闪避', damageReductor: G.hermesBootsDamageReductor};
G['驯狼者的灵魂'] = {name: '驯狼者的灵魂',  desc: '驯狼者的机敏灵魂'};
G.theWolfTrainer = {
	name: '训狼者', 
    exp: 400,
    max_hp: 200,
    hp: 200, 
    power: 12, 
    resistance: 25, 
	legacy: G['hermesBoots'],
    drops: [{
    	item: State.variables['驯狼者的灵魂'], 
        chance: 1.0
    }]
}
G['荒原狼的灵魂'] = {name: '荒原狼的灵魂',  desc: '荒原狼的荒芜灵魂'};
G.theWildWolf = {
	name: '荒原狼', 
    exp: 400,
    max_hp: 200,
    hp: 200, 
    power: 20, 
    resistance: 8, 
	legacy: G.armorPiercingRing,
    drops: [{
    	item: State.variables['荒原狼的灵魂'], 
        chance: 1.0
    }]
}
G['监狱守卫的灵魂'] = {name: '监狱守卫的灵魂',  desc: '监狱守卫的苦闷灵魂'};
G.prisonGuard = {
	name: '监狱守卫', 
    exp: 200,
    max_hp: 180	,
    hp: 180, 
    power: 18, 
    resistance: 18, 
    drops: [{
    	item: State.variables['监狱守卫的灵魂'], 
        chance: 0.6
    }]
}
G['剜眼者的灵魂'] = {name: '剜眼者的灵魂',  desc: '剜眼者的残暴灵魂。从中你感受到某种共鸣——执刀医生般的严谨，以及施虐者的愉悦与狂信。'};
G.deadEyeDamageCalculator = function (me, enemy, fightHistory = []) {
    fightHistory.push(me.name + '的死眼锁定了' + enemy.name + '的要害，暴击100%！');
    let damage = Math.max(1, me.power - enemy.resistance);
    damage = damage * 2;
    return damage;
}
const useDeadEye = () => {
	window.G.me.legacy = G.deadEye;
	window.G.showDialog('装备遗物', '成功装备了' + G.deadEye.name + '!');
}
G.deadEye = {name: '剜眼者', desc: '称手的长柄勺子。比普通的勺子更深，凹陷的部分呈半球形。不具备锋利的边缘，却能给观者带来某种幻痛。会出现在眼科手术室的东西。暴击率百分之百。', damageCalculator: G.deadEyeDamageCalculator, useCallback: useDeadEye};
// TODO: 死眼作为自身的遗物可以被使用
G.theEyeScooper = {
	name: '剜眼者', 
    exp: 500,
    max_hp: 250,
    hp: 250, 
    power: 20, 
    resistance: 20, 
    // 遗物=死眼
    legacy: G.deadEye,
    drops: [{
    	item: G['剜眼者的灵魂'], 
        chance: 1.0
    },{
    	item: G.deadEye, 
        chance: 1.0
    }]
}
// 杀死剜眼者之后的剧情开关
G.plotAfterKillEyeScooperRead = false;
// ============== 2024.12.16 ================
G.glassEyeBall =  {name: '玻璃眼球', desc: '玻璃珠子，我的新眼睛。'};
// ============== 2024.12.30 ================
// 推进剧情
// TODO: 死眼作为自身的遗物可以被使用
G.bloodtheaterUseCb = function(){
	State.variables.me.weapon = G.bloodtheater;
    State.variables.showDialog('装备武器', '成功装备了喋血者!');
}
G.bloodtheater = {name: '喋血者', power: 15, desc: '索尔坦爱用的武器。', useCallback: G.bloodtheaterUseCb}
G.karl = {
	name: '武装后的卡尔', 
    exp: 500,
    max_hp: 300,
    hp: 300, 
    power:  99999, 
    resistance: 25, 
    drops: [{
    	item: G.bloodtheater, 
        chance: 1.0
    }]
}
<</script>>
<<cacheaudio "big_prison" "mp3|https://zhuobinggang.github.io/game/audio/in_big_prison.mp3">>
<</silently>>


:: 遭遇卡尔和军队 {"position":"725,2300","size":"100,100"}
在那黑暗中，有什么东西的轮廓现了出来。
意识到它的时候，兜帽和你都停下了脚步。
无言的压迫感。

迎面传来脚步声。
咔嚓咔嚓，声音在巨大的空洞中回荡，显得十分单薄。

它在梯子旁，微弱的光线下现出了身形——一个身着红色披风，身披盔甲的男人。
“$me.name，你以为我们会乖乖让你逃走吗？”，男人开口了。
是卡尔。

“如果你乖乖等死，我反而会觉得无趣，这样正好。”卡尔将扛着的巨剑插入地面，像仁王一样面对着两人——
“来吧，我会用索尔坦的遗物为他复仇！”

<<link "🔴进入战斗" "战斗画面">>\
	<<set $karl.hp to $karl.max_hp>>\
	<<set $lastPassage to '和卡尔战斗之后'>>\
    <<set $enemyNames to ['karl']>>\
<</link>>



:: StoryScript [script]
window.fightObjectCopy = function(obj){
	let resultObj = {};
	resultObj.name = obj.name;
	resultObj.hp = obj.hp;
	resultObj.max_hp = obj.max_hp;
	resultObj.resistance = obj.resistance;
	resultObj.power = obj.power;
	return resultObj;
}

window.fight = function fight(obj1, obj2, beforeFightCallbacks) {
    const calculateDamage = (attackerPower, defenderResistance) => Math.max(attackerPower - defenderResistance, 1);
    console.log('FIGHT!', obj1, obj2);
    
    let fightHistory = [];
	//循环调用beforeFightCallbacks，每个callback接受obj1和obj2作为参数，最后返回一个字符串作为记录，将这个字符串存入fightHistory。
    beforeFightCallbacks.forEach(callback => {
        // Each callback is called with obj1 and obj2 as arguments
        let result = callback(obj1, obj2);
        // Push the result into the fightHistory array
        fightHistory.push(result);
    });
	
    let { hp: hp1, power: power1, resistance: res1, name: name1 } = obj1;
    let { hp: hp2, power: power2, resistance: res2, name: name2 } = obj2;

    
    let round = 1;

    while (hp1 > 0 && hp2 > 0) {
        fightHistory.push(`回合${round}`);
        let damage = calculateDamage(power1, res2);
        hp2 = Math.max(hp2 - damage, 0);
        fightHistory.push(`${name1}对${name2}造成了${damage}点伤害！`);
        if (hp2 === 0) {
            fightHistory.push(`${name2}倒下了，战斗结束！`);
            break;
        }

        damage = calculateDamage(power2, res1);
        hp1 = Math.max(hp1 - damage, 0);
        fightHistory.push(`${name2}对${name1}造成了${damage}点伤害！`);
        if (hp1 === 0) {
            fightHistory.push(`${name1}倒下了，战斗结束！`);
            break;
        }

        round++;
    }

    obj1.hp = hp1;
    obj2.hp = hp2;
    return fightHistory;
}

function loopCall(callbackName, group1, group2, callbackFuncDict, fightHistory = []){
  	for (let i = 0; i< group1.length; i++){
    	if (callbackFuncDict['g1'][i] && callbackFuncDict['g1'][i][callbackName]) {
        	callbackFuncDict['g1'][i][callbackName](group1, group2, fightHistory);
        }
    }
  	for (let i = 0; i< group2.length; i++){
    	if (callbackFuncDict['g2'][i] && callbackFuncDict['g2'][i][callbackName]) {
        	callbackFuncDict['g2'][i][callbackName](group2, group1, fightHistory);
        }
    }
  	
}

window.groupFight = function groupFight(group1, group2, callbackFuncDict = {'g1': {}, 'g2': {}}) {
  	window.temp2 = callbackFuncDict;

  
    const calculateDamage = (attackerPower, defenderResistance) => Math.max(attackerPower - defenderResistance, 1);
    let fightHistory = [];
    let round = 1;
    
    // 检查所有角色的HP是否都为0
    const isGroupAlive = group => group.some(obj => obj.hp > 0);
  
  	loopCall('groupModifier', group1, group2, callbackFuncDict, fightHistory);
  	console.log('Print our members for check');
  	for (const us of group1){
    	console.log(us.name);
    }

    while (isGroupAlive(group1) && isGroupAlive(group2)) {
        fightHistory.push(`<span class="important">回合${round}</span>`);
        fightHistory.push('<span class="good">' + group1[0].name + '的队伍展开攻击。</span>');
        // Group1攻击Group2
        for (let i = 0; i < group1.length; i++) {
            let obj1 = group1[i]
          	if (obj1.hp <= 0) continue;  // 跳过已倒下的角色
            for (let j = 0; j < group2.length; j++) {
              	const obj2 = group2[j];
                if (obj2.hp <= 0) continue;  // 跳过已倒下的角色
              	let damage = 0;
              	if (i in callbackFuncDict['g1'] && 'damageCalculator' in callbackFuncDict['g1'][i]){
                  	console.log('G1111')
                	damage = callbackFuncDict['g1'][i]['damageCalculator'](obj1, obj2, fightHistory);
                } else {
                	damage = calculateDamage(obj1.power, obj2.resistance);
                }
				// 2024.11.19 被攻击者触发被动 G1[i] 攻击 G2[j]
				if (j in callbackFuncDict['g2'] && 'damageReductor' in callbackFuncDict['g2'][j]){
                  	console.log(obj2.name + '被攻击者触发被动');
                	damage = callbackFuncDict['g2'][j]['damageReductor'](obj1, obj2, damage, fightHistory);
                }
              	fightHistory.push(`${obj1.name}对${obj2.name}造成了${damage}点伤害！`);
              	// 2024.10.27 增加自爆逻辑
              	if (obj2.hp - damage <= 0) {
                	fightHistory.push(`${obj2.name}倒下了！`);
                  	if (j in callbackFuncDict['g2'] && 'deadCallback' in callbackFuncDict['g2'][j]){
                      	console.log(`${obj2.name}的自爆逻辑！`)
                    	callbackFuncDict['g2'][j]['deadCallback'](group2, group1, fightHistory, {round, me: obj2});
                    }
                }
                obj2.hp = Math.max(obj2.hp - damage, 0);
            }
        }

        // 如果group2已经全部倒下，结束战斗
        if (!isGroupAlive(group2)) {
            fightHistory.push(group2[0].name + "的队伍全员倒下，战斗结束！");
            break;
        }

        fightHistory.push('<span class="red">' + group2[0].name + '的队伍展开攻击。</span>');
        // Group2攻击Group1
        for (let i = 0; i < group2.length; i++) {
          	let obj2 = group2[i]
            if (obj2.hp <= 0) continue;  // 跳过已倒下的角色
            for (let j = 0; j < group1.length; j++) {
              	const obj1 = group1[j];
                if (obj1.hp <= 0) continue;  // 跳过已倒下的角色
              	let damage = 0;
              	if (i in callbackFuncDict['g2'] && 'damageCalculator' in callbackFuncDict['g2'][i]){
                  	console.log('G222')
                	damage = callbackFuncDict['g2'][i]['damageCalculator'](obj2, obj1, fightHistory);
                } else {
                	damage = calculateDamage(obj2.power, obj1.resistance);
                }
				// 2024.11.19 被攻击者触发被动 (G2[i]攻击G1[j])
				if (j in callbackFuncDict['g1'] && 'damageReductor' in callbackFuncDict['g1'][j]){
                  	console.log(obj1.name + '被攻击者触发被动');
                	damage = callbackFuncDict['g1'][j]['damageReductor'](obj2, obj1, damage, fightHistory);
                }
              	fightHistory.push(`${obj2.name}对${obj1.name}造成了${damage}点伤害！`);
              	if (obj1.hp - damage <= 0) { // 2024.10.27 增加自爆逻辑
                	fightHistory.push(`${obj1.name}倒下了！`);
                    if (j in callbackFuncDict['g1'] && 'deadCallback' in callbackFuncDict['g1'][j]){
                      	console.log(`${obj1.name}的自爆逻辑！`)
                    	callbackFuncDict['g1'][j]['deadCallback'](group1, group2, fightHistory, {round, me: obj1});
                    }
                }
                obj1.hp = Math.max(obj1.hp - damage, 0);
            }
        }

        // 如果group1已经全部倒下，结束战斗
        if (!isGroupAlive(group1)) {
            fightHistory.push(group1[0].name + "的队伍全员倒下，战斗结束！");
            break;
        }

        round++;
    }

    return fightHistory;
}


window.dropItems = function dropItems(drops) {
    let itemList = [];

    // 遍历drops数组
    drops.forEach(drop => {
        // 生成一个随机数 (0-1)
        let randomChance = Math.random();
      	console.log(randomChance)
      	console.log(drop.chance)
        
        // 如果随机数小于等于掉落几率，则掉落物品
        if (randomChance <= drop.chance) {
          	drop.count = drop.count || 1;
         	for (let i = 0; i < drop.count; i++){
                itemList.push(drop.item);
            }
        }
    });

    return itemList; // 返回掉落的物品列表
}

window.dropString = function dropString(droppedItems) {
    // 如果 droppedItems 为空，返回提示信息
    if (droppedItems.length === 0) {
        return "没有物品掉落";
    }

    // 使用一个对象来统计每种物品的数量
    let itemCountMap = {};
    droppedItems.forEach(item => {
        // 如果该物品已经在对象中，增加数量；否则，初始化为1
        if (itemCountMap[item.name]) {
            itemCountMap[item.name]++;
        } else {
            itemCountMap[item.name] = 1;
        }
    });

    // 将统计结果转换成字符串，显示掉落数量
    let itemDescriptions = Object.keys(itemCountMap).map(name => {
        let count = itemCountMap[name];
        return count > 1 ? `${count}个${name}` : `1个${name}`;
    });

    // 返回拼接后的字符串
    return itemDescriptions.join('，');
}

window.addToInventory = function(inventory, itemList) {
    itemList.forEach(item => {
        // 检查 inventory 中是否已有该物品
        let existingItem = inventory.find(inventoryItem => inventoryItem.name === item.name);
        
        if (existingItem) {
            // 如果已有该物品，增加 count
            existingItem.count++;
        } else {
            // 如果没有，新增物品并设置 count 为 1
            inventory.push({ ...item, count: 1 });
        }
    });
}

window.checkHavingItem = function(inventory, itemName) {
    // 查找 inventory 中的物品
    let item = inventory.find(inventoryItem => inventoryItem.name === itemName);
    
    // 如果物品不存在，或者 count 为 0，返回 false（不持有）
    if (!item || item.count === 0) {
        return false;
    }
    
    // 否则返回 true（持有）
    return true;
}

window.getItem = function getItem(inventory, itemName) {
    // 查找 inventory 中的物品
    let item = inventory.find(inventoryItem => inventoryItem.name === itemName);
    
    // 如果物品存在，返回该物品，否则返回 null
    return item || null;
}

window.reduceItemCount = function reduceItemCount(inventory, itemName, count) {
    // 查找 inventory 中的物品
    let item = inventory.find(inventoryItem => inventoryItem.name === itemName);
    
    if (item) {
        // 减少物品数量
        item.count -= count;
        
        // 如果物品数量小于等于 0，将 count 设为 0
        if (item.count <= 0) {
            item.count = 0;
        }
    } else {
        console.log(`物品 ${itemName} 不存在于 inventory 中。`);
    }
}

window.addItem = function addItem(inventory, item, count = 1) {
    // 查找是否已有该物品
    let existingItem = inventory.find(inventoryItem => inventoryItem.name === item.name);
    
    if (existingItem) {
        // 如果持有，更新物品的数量和描述
        existingItem.count += count;
        existingItem.desc = item.desc;  // 更新物品的描述
    } else {
        // 如果不持有，新增物品并设置 count
        inventory.push({ ...item, count: count });
    }
}

window.healing = function healing(target, percentage) {
    // 计算恢复的生命值
    const healAmount = target.max_hp * percentage;
    
    // 增加生命值，但不能超过max_hp
    target.hp = Math.min(target.hp + healAmount, target.max_hp);
    
    return target.hp; // 返回更新后的生命值
  
}

// 升级
window.levelUp = function(target){
  	target.level += 1
  	target.intrinsicPower += 1
  	target.intrinsicResistance += 1
  	target.max_hp += 10
  	console.log(target.name + ' Level Up!')
}

window.expCurve = function expCurve(level) {
    return Math.floor(5 * Math.pow(level, 2)); // 经验值需求递增曲线
}

window.expGot = function expGot(expBefore, expGot, level, levelUp) {
    let expNew = expBefore + expGot; // 计算新经验值
    let levelsGained = 0; // 用于追踪升了多少级

    // 循环检查是否可以升级
    while (expNew >= expCurve(level)) {
        expNew -= expCurve(level); // 减去当前级别的经验需求
        level += 1; // 升一级
        levelsGained += 1; // 记录升一级
        levelUp(); // 调用levelUp函数
    }

    return { newExp: expNew, newLevel: level, levelsGained: levelsGained };
}
console.log('难道说每次都要重新？')

//@deprecated 因为自动生成的法杖无法保存在游戏状态中，必须复制手写。
window.summonRodProduce = function(rodName, familiarName, prototFightObj, desc = ''){
	const useRod = () => {
		console.log('我在这里啊')
		window.G.me.ring = G[rodName];
		window.G.showDialog('装备遗物', '成功装备了' + rodName + '!');
	}
	const groupModifier = (group1, group2, fightHistory) => {
		const spawned = fightObjectCopy(prototFightObj);
		spawned.name = familiarName;
		group1.push(spawned);
		console.log(rodName + '为' + group1[0].name + '的队伍召唤了' + familiarName + '!');
		fightHistory.push(rodName + '为' + group1[0].name + '的队伍召唤了' + familiarName + '!');
	}
	const newDesc = desc || '召唤一只' + familiarName + '协同战斗。';
	window.G[rodName] = {name: rodName, desc: newDesc, groupModifier: groupModifier, useCallback: useRod};
}


window.mergeBattleLogs = function mergeBattleLogs(battleLogs) {
  const rounds = [];
  let currentRound = [];

  // 1. 分割为不同的回合部分
  for (let i = 0; i < battleLogs.length; i++) {
    const log = battleLogs[i];
    if (log.startsWith('<span class="important">回合')) {
      // 如果有累积的回合数据，先推入 rounds
      if (currentRound.length > 0) {
        rounds.push(currentRound);
        currentRound = [];
      }
    }
    currentRound.push(log);
  }
  // 推入最后一回合
  if (currentRound.length > 0) {
    rounds.push(currentRound);
  }

  const result = [];
  let previousRoundContent = null;
  let repeatRoundIndex = null;

  // 2. 合并相同回合部分
  for (let i = 0; i < rounds.length; i++) {
    const round = rounds[i];
    const roundContent = round.slice(1); // 去掉"回合n"的内容，仅比较回合内的具体内容

    if (previousRoundContent && JSON.stringify(roundContent) === JSON.stringify(previousRoundContent)) {
      // 如果当前回合内容和前一回合内容相同，标记为重复
      if (repeatRoundIndex === null) {
        repeatRoundIndex = i;
      }
    } else {
      // 如果内容不同，先把之前的重复合并
      if (repeatRoundIndex !== null) {
        result.push(`<span class="important">回合……</span>`);
        repeatRoundIndex = null;
      }
      result.push(...round);  // 当前回合内容直接加入
      previousRoundContent = roundContent;
    }
  }

  // 处理最后的重复内容
  if (repeatRoundIndex !== null) {
    result.push(`回合${repeatRoundIndex + 1}……`);
  }

  return result;
}

:: StoryStylesheet [stylesheet]
.danger{
	color: red;
}
.good{
	color: #90EE90;
}
.important{
  	color: orange;
}
.red{
	color: red;
}
.purple{
  	color: purple;
}
.orange{
  	color: orange;
}
#history-forward{
	visibility: hidden;
}
#history-backward{
	visibility: hidden;
}
div.aa pre{
    font-family: Mona,'MS PGothic' !important; 
    line-height: 100% !important;
}